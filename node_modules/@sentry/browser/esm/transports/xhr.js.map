{"version":3,"file":"xhr.js","sourceRoot":"","sources":["../../../../src/transports/xhr.ts"],"names":[],"mappings":";AACA,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAEzD,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,4BAA4B;AAC5B;IAAkC,gCAAa;IAA/C;;IAwDA,CAAC;IAvDC;;;OAGG;IACO,mCAAY,GAAtB,UAAuB,aAA4B,EAAE,eAAgC;QAArF,iBAkDC;QAjDC,mDAAmD;QACnD,IAAI,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;YAC3C,IAAI,CAAC,eAAe,CAAC,mBAAmB,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;YAE9D,OAAO,OAAO,CAAC,MAAM,CAAC;gBACpB,KAAK,EAAE,eAAe;gBACtB,IAAI,EAAE,aAAa,CAAC,IAAI;gBACxB,mDAAmD;gBACnD,MAAM,EAAE,mBAAiB,aAAa,CAAC,IAAI,8BAAyB,IAAI,CAAC,cAAc,CACrF,aAAa,CAAC,IAAI,CACnB,+BAA4B;gBAC7B,MAAM,EAAE,GAAG;aACZ,CAAC,CAAC;SACJ;QAED,OAAO,IAAI,CAAC,OAAO;aAChB,GAAG,CACF;YACE,OAAA,IAAI,WAAW,CAAW,UAAC,OAAO,EAAE,MAAM;gBACxC,IAAM,OAAO,GAAG,IAAI,cAAc,EAAE,CAAC;gBAErC,OAAO,CAAC,kBAAkB,GAAG;oBAC3B,IAAI,OAAO,CAAC,UAAU,KAAK,CAAC,EAAE;wBAC5B,IAAM,OAAO,GAAG;4BACd,sBAAsB,EAAE,OAAO,CAAC,iBAAiB,CAAC,sBAAsB,CAAC;4BACzE,aAAa,EAAE,OAAO,CAAC,iBAAiB,CAAC,aAAa,CAAC;yBACxD,CAAC;wBACF,KAAI,CAAC,eAAe,CAAC,EAAE,WAAW,EAAE,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,SAAA,EAAE,OAAO,SAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;qBACxG;gBACH,CAAC,CAAC;gBAEF,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC;gBACxC,KAAK,IAAM,MAAM,IAAI,KAAI,CAAC,OAAO,CAAC,OAAO,EAAE;oBACzC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAI,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;wBACtE,OAAO,CAAC,gBAAgB,CAAC,MAAM,EAAE,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;qBAChE;iBACF;gBACD,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACnC,CAAC,CAAC;QApBF,CAoBE,CACL;aACA,IAAI,CAAC,SAAS,EAAE,UAAA,MAAM;YACrB,gGAAgG;YAChG,IAAI,MAAM,YAAY,WAAW,EAAE;gBACjC,KAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;aAC5D;iBAAM;gBACL,KAAI,CAAC,eAAe,CAAC,eAAe,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;aAC3D;YACD,MAAM,MAAM,CAAC;QACf,CAAC,CAAC,CAAC;IACP,CAAC;IACH,mBAAC;AAAD,CAAC,AAxDD,CAAkC,aAAa,GAwD9C","sourcesContent":["import { Event, Response, SentryRequest, Session } from '@sentry/types';\nimport { SentryError, SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\n/** `XHR` based transport */\nexport class XHRTransport extends BaseTransport {\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  protected _sendRequest(sentryRequest: SentryRequest, originalPayload: Event | Session): PromiseLike<Response> {\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(sentryRequest.type)) {\n      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);\n\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        // eslint-disable-next-line deprecation/deprecation\n        reason: `Transport for ${sentryRequest.type} requests locked till ${this._disabledUntil(\n          sentryRequest.type,\n        )} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    return this._buffer\n      .add(\n        () =>\n          new SyncPromise<Response>((resolve, reject) => {\n            const request = new XMLHttpRequest();\n\n            request.onreadystatechange = (): void => {\n              if (request.readyState === 4) {\n                const headers = {\n                  'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n                  'retry-after': request.getResponseHeader('Retry-After'),\n                };\n                this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });\n              }\n            };\n\n            request.open('POST', sentryRequest.url);\n            for (const header in this.options.headers) {\n              if (Object.prototype.hasOwnProperty.call(this.options.headers, header)) {\n                request.setRequestHeader(header, this.options.headers[header]);\n              }\n            }\n            request.send(sentryRequest.body);\n          }),\n      )\n      .then(undefined, reason => {\n        // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.\n        if (reason instanceof SentryError) {\n          this.recordLostEvent('queue_overflow', sentryRequest.type);\n        } else {\n          this.recordLostEvent('network_error', sentryRequest.type);\n        }\n        throw reason;\n      });\n  }\n}\n"]}