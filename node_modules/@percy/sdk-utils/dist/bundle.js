(function() {
  (function (exports) {
    'use strict';

    const process = (typeof globalThis !== "undefined" && globalThis.process) || {};
    process.env = process.env || {};
    process.env.__PERCY_BROWSERIFIED__ = true;

    // helper to create a version object from a string
    function toVersion(str) {
      str || (str = '0.0.0');
      return str.split(/\.|-/).reduce((version, part, i) => {
        let v = parseInt(part, 10);
        version[i] = isNaN(v) ? part : v;
        return version;
      }, {
        get major() {
          return this[0] || 0;
        },

        get minor() {
          return this[1] || 0;
        },

        get patch() {
          return this[2] || 0;
        },

        get prerelease() {
          return this[3];
        },

        get build() {
          return this[4];
        },

        toString() {
          return str;
        }

      });
    } // private version cache


    let version = toVersion(); // contains local percy info

    const info = {
      // get or set the CLI API address via the environment
      get address() {
        return process.env.PERCY_SERVER_ADDRESS || 'http://localhost:5338';
      },

      set address(addr) {
        return process.env.PERCY_SERVER_ADDRESS = addr;
      },

      // version information
      get version() {
        return version;
      },

      set version(v) {
        return version = toVersion(v);
      }

    };

    const LOG_LEVELS = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    }; // Create a small logger util using the specified namespace

    function logger(namespace) {
      return Object.keys(LOG_LEVELS).reduce((ns, lvl) => Object.assign(ns, {
        [lvl]: function () {
          for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
            a[_key] = arguments[_key];
          }

          return logger.log(namespace, lvl, ...a);
        }
      }), {});
    } // Set and/or return the local loglevel

    const loglevel = logger.loglevel = lvl => {
      return loglevel.lvl = lvl || loglevel.lvl || process.env.PERCY_LOGLEVEL || 'info';
    }; // Track and send/write logs for the specified namespace and log level


    const log = logger.log = (ns, lvl, msg, meta) => {
      let err = typeof msg !== 'string' && (lvl === 'error' || lvl === 'debug');
      meta = {
        remote: true,
        ...meta
      };

      if (remote.socket) {
        // prefer remote logging when available and serialize any errors
        if (err) msg = {
          name: msg.name,
          message: msg.message,
          stack: msg.stack
        };
        return remote.socket.send(JSON.stringify({
          log: [ns, lvl, msg, meta]
        }));
      } else {
        // keep log history when not remote
        let [debug, level, message, timestamp] = [ns, lvl, msg, Date.now()];
        (log.history || (log.history = [])).push({
          debug,
          level,
          message,
          meta,
          timestamp
        });
      } // check if the specific level is within the local loglevel range


      if (LOG_LEVELS[lvl] != null && LOG_LEVELS[lvl] >= LOG_LEVELS[loglevel()]) {
        var _msg;

        let debug = loglevel() === 'debug';
        let label = debug ? `percy:${ns}` : 'percy'; // colorize the label when possible for consistency with the CLI logger

        if (!process.env.__PERCY_BROWSERIFIED__) label = `\u001b[95m${label}\u001b[39m`;
        msg = `[${label}] ${err && debug && ((_msg = msg) === null || _msg === void 0 ? void 0 : _msg.stack) || msg}`;

        if (process.env.__PERCY_BROWSERIFIED__) {
          // use console[warn|error|log] in browsers
          console[['warn', 'error'].includes(lvl) ? lvl : 'log'](msg);
        } else {
          // use process[stdout|stderr].write in node
          process[lvl === 'info' ? 'stdout' : 'stderr'].write(msg + '\n');
        }
      }
    }; // Create a new WebSocket and resolve with it once connected


    async function createWebSocket(address) {
      let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      // attempt to import `ws` in node environments
      let WebSocket = process.env.__PERCY_BROWSERIFIED__
      /* eslint-disable-next-line import/no-extraneous-dependencies */
      ? window.WebSocket : (await ({})).default;
      let ws = new WebSocket(address.replace(/^http/, 'ws'));
      return new Promise((resolve, reject) => {
        let done = ws.onopen = ws.onerror = e => {
          var _ws$_socket;

          (_ws$_socket = ws._socket) === null || _ws$_socket === void 0 ? void 0 : _ws$_socket.unref();
          clearTimeout(timeoutid);
          ws.onopen = ws.onerror = null;
          if (!e.error && e.type !== 'error') return resolve(ws);else reject(e.error || 'Error: Socket connection failed');
        };

        let timeoutid = setTimeout(done, timeout, {
          error: 'Error: Socket connection timed out'
        });
      });
    } // Connect to a remote logger at the specified address within the timeout


    const remote = logger.remote = async timeout => {
      try {
        var _remote$socket;

        // already connected
        if (((_remote$socket = remote.socket) === null || _remote$socket === void 0 ? void 0 : _remote$socket.readyState) === 1) return; // connect to namespaced logging address

        let address = new URL('/logger', info.address).href; // create and cache a websocket connection

        let ws = remote.socket = await createWebSocket(address, timeout); // accept loglevel updates

        /* istanbul ignore next: difficult to test currently */

        ws.onmessage = e => loglevel(JSON.parse(e.data).loglevel); // cleanup message handler on close


        ws.onclose = () => remote.socket = ws.onmessage = ws.onclose = null; // send any messages already logged in this environment


        if (log.history) ws.send(JSON.stringify({
          messages: log.history
        }));
      } catch (err) {
        // there was an error connecting, will fallback to minimal logging
        logger.log('utils', 'debug', 'Unable to connect to remote logger');
        logger.log('utils', 'debug', err);
      }
    };

    async function request(path) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let response = await request.fetch(`${info.address}${path}`, options); // maybe parse response body as json

      if (typeof response.body === 'string' && response.headers['content-type'] === 'application/json') {
        try {
          response.body = JSON.parse(response.body);
        } catch (e) {}
      } // throw an error if status is not ok


      if (!(response.status >= 200 && response.status < 300)) {
        throw Object.assign(new Error(), {
          message: response.body.error || `${response.status} ${response.statusText}`,
          response
        });
      }

      return response;
    }

    request.post = function post(url, json) {
      return request(url, {
        method: 'POST',
        body: JSON.stringify(json)
      });
    }; // environment specific implementation


    if (process.env.__PERCY_BROWSERIFIED__) {
      // use window.fetch in browsers
      const winFetch = window.fetch;

      request.fetch = async function fetch(url, options) {
        let response = await winFetch(url, options);
        return {
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries()),
          body: await response.text()
        };
      };
    } else {
      // use http.request in node
      request.fetch = async function fetch(url, options) {
        let {
          default: http
        } = await ({});
        return new Promise((resolve, reject) => {
          http.request(url, options).on('response', response => {
            let body = '';
            response.on('data', chunk => body += chunk.toString());
            response.on('end', () => resolve({
              status: response.statusCode,
              statusText: response.statusMessage,
              headers: response.headers,
              body
            }));
          }).on('error', reject).end(options.body);
        });
      };
    }

    async function isPercyEnabled() {
      if (info.enabled == null) {
        let log = logger('utils');
        let error;

        try {
          let response = await request('/percy/healthcheck');
          info.version = response.headers['x-percy-core-version'];
          info.config = response.body.config;
          info.enabled = true;
        } catch (e) {
          info.enabled = false;
          error = e;
        }

        if (info.enabled && info.version.major !== 1) {
          log.info('Unsupported Percy CLI version, disabling snapshots');
          log.debug(`Found version: ${info.version}`);
          info.enabled = false;
        } else if (!info.enabled) {
          log.info('Percy is not running, disabling snapshots');
          log.debug(error);
        }

        if (info.enabled) {
          await logger.remote();
        }
      }

      return info.enabled;
    }

    const RETRY_ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT'];
    async function waitForPercyIdle() {
      try {
        return !!(await request('/percy/idle'));
      } catch (e) {
        return RETRY_ERROR_CODES.includes(e.code) && waitForPercyIdle();
      }
    }

    async function fetchPercyDOM() {
      if (info.domScript == null) {
        let response = await request('/percy/dom.js');
        info.domScript = response.body;
      }

      return info.domScript;
    }

    // error message, signal that Percy has been disabled.

    async function postSnapshot(options, params) {
      let query = params ? `?${new URLSearchParams(params)}` : '';
      await request.post(`/percy/snapshot${query}`, options).catch(err => {
        var _err$response, _err$response$body, _err$response$body$bu;

        if ((_err$response = err.response) !== null && _err$response !== void 0 && (_err$response$body = _err$response.body) !== null && _err$response$body !== void 0 && (_err$response$body$bu = _err$response$body.build) !== null && _err$response$body$bu !== void 0 && _err$response$body$bu.error) {
          info.enabled = false;
        } else {
          throw err;
        }
      });
    }

    var index = /*#__PURE__*/Object.freeze({
      __proto__: null,
      logger: logger,
      percy: info,
      request: request,
      isPercyEnabled: isPercyEnabled,
      waitForPercyIdle: waitForPercyIdle,
      fetchPercyDOM: fetchPercyDOM,
      postSnapshot: postSnapshot,
      'default': index
    });

    exports["default"] = index;
    exports.fetchPercyDOM = fetchPercyDOM;
    exports.isPercyEnabled = isPercyEnabled;
    exports.logger = logger;
    exports.percy = info;
    exports.postSnapshot = postSnapshot;
    exports.request = request;
    exports.waitForPercyIdle = waitForPercyIdle;

    Object.defineProperty(exports, '__esModule', { value: true });

  })(this.PercySDKUtils = this.PercySDKUtils || {});
}).call(window);

if (typeof define === "function" && define.amd) {
  define([], () => window.PercySDKUtils);
} else if (typeof module === "object" && module.exports) {
  module.exports = window.PercySDKUtils;
}
