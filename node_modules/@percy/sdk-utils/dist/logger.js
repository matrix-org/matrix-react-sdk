"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.logger = logger;

var _percyInfo = _interopRequireDefault(require("./percy-info.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Used when determining if a message should be logged
const LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
}; // Create a small logger util using the specified namespace

function logger(namespace) {
  return Object.keys(LOG_LEVELS).reduce((ns, lvl) => Object.assign(ns, {
    [lvl]: (...a) => logger.log(namespace, lvl, ...a)
  }), {});
} // Set and/or return the local loglevel


const loglevel = logger.loglevel = lvl => {
  return loglevel.lvl = lvl || loglevel.lvl || process.env.PERCY_LOGLEVEL || 'info';
}; // Track and send/write logs for the specified namespace and log level


const log = logger.log = (ns, lvl, msg, meta) => {
  let err = typeof msg !== 'string' && (lvl === 'error' || lvl === 'debug');
  meta = {
    remote: true,
    ...meta
  };

  if (remote.socket) {
    // prefer remote logging when available and serialize any errors
    if (err) msg = {
      name: msg.name,
      message: msg.message,
      stack: msg.stack
    };
    return remote.socket.send(JSON.stringify({
      log: [ns, lvl, msg, meta]
    }));
  } else {
    // keep log history when not remote
    let [debug, level, message, timestamp] = [ns, lvl, msg, Date.now()];
    (log.history || (log.history = [])).push({
      debug,
      level,
      message,
      meta,
      timestamp
    });
  } // check if the specific level is within the local loglevel range


  if (LOG_LEVELS[lvl] != null && LOG_LEVELS[lvl] >= LOG_LEVELS[loglevel()]) {
    var _msg;

    let debug = loglevel() === 'debug';
    let label = debug ? `percy:${ns}` : 'percy'; // colorize the label when possible for consistency with the CLI logger

    if (!process.env.__PERCY_BROWSERIFIED__) label = `\u001b[95m${label}\u001b[39m`;
    msg = `[${label}] ${err && debug && ((_msg = msg) === null || _msg === void 0 ? void 0 : _msg.stack) || msg}`;

    if (process.env.__PERCY_BROWSERIFIED__) {
      // use console[warn|error|log] in browsers
      console[['warn', 'error'].includes(lvl) ? lvl : 'log'](msg);
    } else {
      // use process[stdout|stderr].write in node
      process[lvl === 'info' ? 'stdout' : 'stderr'].write(msg + '\n');
    }
  }
}; // Create a new WebSocket and resolve with it once connected


async function createWebSocket(address, timeout = 1000) {
  // attempt to import `ws` in node environments
  let WebSocket = process.env.__PERCY_BROWSERIFIED__
  /* eslint-disable-next-line import/no-extraneous-dependencies */
  ? window.WebSocket : (await Promise.resolve().then(() => _interopRequireWildcard(require('ws')))).default;
  let ws = new WebSocket(address.replace(/^http/, 'ws'));
  return new Promise((resolve, reject) => {
    let done = ws.onopen = ws.onerror = e => {
      var _ws$_socket;

      (_ws$_socket = ws._socket) === null || _ws$_socket === void 0 ? void 0 : _ws$_socket.unref();
      clearTimeout(timeoutid);
      ws.onopen = ws.onerror = null;
      if (!e.error && e.type !== 'error') return resolve(ws);else reject(e.error || 'Error: Socket connection failed');
    };

    let timeoutid = setTimeout(done, timeout, {
      error: 'Error: Socket connection timed out'
    });
  });
} // Connect to a remote logger at the specified address within the timeout


const remote = logger.remote = async timeout => {
  try {
    var _remote$socket;

    // already connected
    if (((_remote$socket = remote.socket) === null || _remote$socket === void 0 ? void 0 : _remote$socket.readyState) === 1) return; // connect to namespaced logging address

    let address = new URL('/logger', _percyInfo.default.address).href; // create and cache a websocket connection

    let ws = remote.socket = await createWebSocket(address, timeout); // accept loglevel updates

    /* istanbul ignore next: difficult to test currently */

    ws.onmessage = e => loglevel(JSON.parse(e.data).loglevel); // cleanup message handler on close


    ws.onclose = () => remote.socket = ws.onmessage = ws.onclose = null; // send any messages already logged in this environment


    if (log.history) ws.send(JSON.stringify({
      messages: log.history
    }));
  } catch (err) {
    // there was an error connecting, will fallback to minimal logging
    logger.log('utils', 'debug', 'Unable to connect to remote logger');
    logger.log('utils', 'debug', err);
  }
};

var _default = logger;
exports.default = _default;