var rrwebSnapshot = (function (exports) {
  'use strict';

  (function (NodeType) {
      NodeType[NodeType["Document"] = 0] = "Document";
      NodeType[NodeType["DocumentType"] = 1] = "DocumentType";
      NodeType[NodeType["Element"] = 2] = "Element";
      NodeType[NodeType["Text"] = 3] = "Text";
      NodeType[NodeType["CDATA"] = 4] = "CDATA";
      NodeType[NodeType["Comment"] = 5] = "Comment";
  })(exports.NodeType || (exports.NodeType = {}));

  function isElement(n) {
      return n.nodeType === n.ELEMENT_NODE;
  }
  function isShadowRoot(n) {
      var _a;
      var host = (_a = n) === null || _a === void 0 ? void 0 : _a.host;
      return Boolean(host && host.shadowRoot && host.shadowRoot === n);
  }
  function maskInputValue(_a) {
      var maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
      var text = value || '';
      if (maskInputOptions[tagName.toLowerCase()] ||
          maskInputOptions[type]) {
          if (maskInputFn) {
              text = maskInputFn(text);
          }
          else {
              text = '*'.repeat(text.length);
          }
      }
      return text;
  }

  var _id = 1;
  var tagNameRegex = RegExp('[^a-z0-9-_:]');
  var IGNORED_NODE = -2;
  function genId() {
      return _id++;
  }
  function getValidTagName(element) {
      if (element instanceof HTMLFormElement) {
          return 'form';
      }
      var processedTagName = element.tagName.toLowerCase().trim();
      if (tagNameRegex.test(processedTagName)) {
          return 'div';
      }
      return processedTagName;
  }
  function getCssRulesString(s) {
      try {
          var rules = s.rules || s.cssRules;
          return rules ? Array.from(rules).map(getCssRuleString).join('') : null;
      }
      catch (error) {
          return null;
      }
  }
  function getCssRuleString(rule) {
      return isCSSImportRule(rule)
          ? getCssRulesString(rule.styleSheet) || ''
          : rule.cssText;
  }
  function isCSSImportRule(rule) {
      return 'styleSheet' in rule;
  }
  function extractOrigin(url) {
      var origin;
      if (url.indexOf('//') > -1) {
          origin = url.split('/').slice(0, 3).join('/');
      }
      else {
          origin = url.split('/')[0];
      }
      origin = origin.split('?')[0];
      return origin;
  }
  var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
  var RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/;
  var DATA_URI = /^(data:)([^,]*),(.*)/i;
  function absoluteToStylesheet(cssText, href) {
      return (cssText || '').replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {
          var filePath = path1 || path2 || path3;
          var maybeQuote = quote1 || quote2 || '';
          if (!filePath) {
              return origin;
          }
          if (!RELATIVE_PATH.test(filePath)) {
              return "url(" + maybeQuote + filePath + maybeQuote + ")";
          }
          if (DATA_URI.test(filePath)) {
              return "url(" + maybeQuote + filePath + maybeQuote + ")";
          }
          if (filePath[0] === '/') {
              return "url(" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + ")";
          }
          var stack = href.split('/');
          var parts = filePath.split('/');
          stack.pop();
          for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
              var part = parts_1[_i];
              if (part === '.') {
                  continue;
              }
              else if (part === '..') {
                  stack.pop();
              }
              else {
                  stack.push(part);
              }
          }
          return "url(" + maybeQuote + stack.join('/') + maybeQuote + ")";
      });
  }
  var SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
  var SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
  function getAbsoluteSrcsetString(doc, attributeValue) {
      if (attributeValue.trim() === '') {
          return attributeValue;
      }
      var pos = 0;
      function collectCharacters(regEx) {
          var chars, match = regEx.exec(attributeValue.substring(pos));
          if (match) {
              chars = match[0];
              pos += chars.length;
              return chars;
          }
          return '';
      }
      var output = [];
      while (true) {
          collectCharacters(SRCSET_COMMAS_OR_SPACES);
          if (pos >= attributeValue.length) {
              break;
          }
          var url = collectCharacters(SRCSET_NOT_SPACES);
          if (url.slice(-1) === ',') {
              url = absoluteToDoc(doc, url.substring(0, url.length - 1));
              output.push(url);
          }
          else {
              var descriptorsStr = '';
              url = absoluteToDoc(doc, url);
              var inParens = false;
              while (true) {
                  var c = attributeValue.charAt(pos);
                  if (c === '') {
                      output.push((url + descriptorsStr).trim());
                      break;
                  }
                  else if (!inParens) {
                      if (c === ',') {
                          pos += 1;
                          output.push((url + descriptorsStr).trim());
                          break;
                      }
                      else if (c === '(') {
                          inParens = true;
                      }
                  }
                  else {
                      if (c === ')') {
                          inParens = false;
                      }
                  }
                  descriptorsStr += c;
                  pos += 1;
              }
          }
      }
      return output.join(', ');
  }
  function absoluteToDoc(doc, attributeValue) {
      if (!attributeValue || attributeValue.trim() === '') {
          return attributeValue;
      }
      var a = doc.createElement('a');
      a.href = attributeValue;
      return a.href;
  }
  function isSVGElement(el) {
      return el.tagName === 'svg' || el instanceof SVGElement;
  }
  function getHref() {
      var a = document.createElement('a');
      a.href = '';
      return a.href;
  }
  function transformAttribute(doc, tagName, name, value) {
      if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {
          return absoluteToDoc(doc, value);
      }
      else if (name === 'background' &&
          value &&
          (tagName === 'table' || tagName === 'td' || tagName === 'th')) {
          return absoluteToDoc(doc, value);
      }
      else if (name === 'srcset' && value) {
          return getAbsoluteSrcsetString(doc, value);
      }
      else if (name === 'style' && value) {
          return absoluteToStylesheet(value, getHref());
      }
      else {
          return value;
      }
  }
  function _isBlockedElement(element, blockClass, blockSelector) {
      if (typeof blockClass === 'string') {
          if (element.classList.contains(blockClass)) {
              return true;
          }
      }
      else {
          for (var eIndex = 0; eIndex < element.classList.length; eIndex++) {
              var className = element.classList[eIndex];
              if (blockClass.test(className)) {
                  return true;
              }
          }
      }
      if (blockSelector) {
          return element.matches(blockSelector);
      }
      return false;
  }
  function needMaskingText(node, maskTextClass, maskTextSelector) {
      if (!node) {
          return false;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
          if (typeof maskTextClass === 'string') {
              if (node.classList.contains(maskTextClass)) {
                  return true;
              }
          }
          else {
              node.classList.forEach(function (className) {
                  if (maskTextClass.test(className)) {
                      return true;
                  }
              });
          }
          if (maskTextSelector) {
              if (node.matches(maskTextSelector)) {
                  return true;
              }
          }
          return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
      }
      if (node.nodeType === node.TEXT_NODE) {
          return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
      }
      return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
  }
  function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
      var win = iframeEl.contentWindow;
      if (!win) {
          return;
      }
      var fired = false;
      var readyState;
      try {
          readyState = win.document.readyState;
      }
      catch (error) {
          return;
      }
      if (readyState !== 'complete') {
          var timer_1 = setTimeout(function () {
              if (!fired) {
                  listener();
                  fired = true;
              }
          }, iframeLoadTimeout);
          iframeEl.addEventListener('load', function () {
              clearTimeout(timer_1);
              fired = true;
              listener();
          });
          return;
      }
      var blankUrl = 'about:blank';
      if (win.location.href !== blankUrl ||
          iframeEl.src === blankUrl ||
          iframeEl.src === '') {
          setTimeout(listener, 0);
          return;
      }
      iframeEl.addEventListener('load', listener);
  }
  function serializeNode(n, options) {
      var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _a = options.maskInputOptions, maskInputOptions = _a === void 0 ? {} : _a, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
      var rootId;
      if (doc.__sn) {
          var docId = doc.__sn.id;
          rootId = docId === 1 ? undefined : docId;
      }
      switch (n.nodeType) {
          case n.DOCUMENT_NODE:
              return {
                  type: exports.NodeType.Document,
                  childNodes: [],
                  rootId: rootId,
              };
          case n.DOCUMENT_TYPE_NODE:
              return {
                  type: exports.NodeType.DocumentType,
                  name: n.name,
                  publicId: n.publicId,
                  systemId: n.systemId,
                  rootId: rootId,
              };
          case n.ELEMENT_NODE:
              var needBlock = _isBlockedElement(n, blockClass, blockSelector);
              var tagName = getValidTagName(n);
              var attributes_1 = {};
              for (var _i = 0, _b = Array.from(n.attributes); _i < _b.length; _i++) {
                  var _c = _b[_i], name = _c.name, value = _c.value;
                  attributes_1[name] = transformAttribute(doc, tagName, name, value);
              }
              if (tagName === 'link' && inlineStylesheet) {
                  var stylesheet = Array.from(doc.styleSheets).find(function (s) {
                      return s.href === n.href;
                  });
                  var cssText = getCssRulesString(stylesheet);
                  if (cssText) {
                      delete attributes_1.rel;
                      delete attributes_1.href;
                      attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);
                  }
              }
              if (tagName === 'style' &&
                  n.sheet &&
                  !(n.innerText ||
                      n.textContent ||
                      '').trim().length) {
                  var cssText = getCssRulesString(n.sheet);
                  if (cssText) {
                      attributes_1._cssText = absoluteToStylesheet(cssText, getHref());
                  }
              }
              if (tagName === 'input' ||
                  tagName === 'textarea' ||
                  tagName === 'select') {
                  var value = n.value;
                  if (attributes_1.type !== 'radio' &&
                      attributes_1.type !== 'checkbox' &&
                      attributes_1.type !== 'submit' &&
                      attributes_1.type !== 'button' &&
                      value) {
                      attributes_1.value = maskInputValue({
                          type: attributes_1.type,
                          tagName: tagName,
                          value: value,
                          maskInputOptions: maskInputOptions,
                          maskInputFn: maskInputFn,
                      });
                  }
                  else if (n.checked) {
                      attributes_1.checked = n.checked;
                  }
              }
              if (tagName === 'option') {
                  var selectValue = n.parentElement;
                  if (attributes_1.value === selectValue.value) {
                      attributes_1.selected = n.selected;
                  }
              }
              if (tagName === 'canvas' && recordCanvas) {
                  attributes_1.rr_dataURL = n.toDataURL();
              }
              if (tagName === 'audio' || tagName === 'video') {
                  attributes_1.rr_mediaState = n.paused
                      ? 'paused'
                      : 'played';
                  attributes_1.rr_mediaCurrentTime = n.currentTime;
              }
              if (n.scrollLeft) {
                  attributes_1.rr_scrollLeft = n.scrollLeft;
              }
              if (n.scrollTop) {
                  attributes_1.rr_scrollTop = n.scrollTop;
              }
              if (needBlock) {
                  var _d = n.getBoundingClientRect(), width = _d.width, height = _d.height;
                  attributes_1 = {
                      class: attributes_1.class,
                      rr_width: width + "px",
                      rr_height: height + "px",
                  };
              }
              if (tagName === 'iframe' && !keepIframeSrcFn(attributes_1.src)) {
                  delete attributes_1.src;
              }
              return {
                  type: exports.NodeType.Element,
                  tagName: tagName,
                  attributes: attributes_1,
                  childNodes: [],
                  isSVG: isSVGElement(n) || undefined,
                  needBlock: needBlock,
                  rootId: rootId,
              };
          case n.TEXT_NODE:
              var parentTagName = n.parentNode && n.parentNode.tagName;
              var textContent = n.textContent;
              var isStyle = parentTagName === 'STYLE' ? true : undefined;
              var isScript = parentTagName === 'SCRIPT' ? true : undefined;
              if (isStyle && textContent) {
                  textContent = absoluteToStylesheet(textContent, getHref());
              }
              if (isScript) {
                  textContent = 'SCRIPT_PLACEHOLDER';
              }
              if (!isStyle &&
                  !isScript &&
                  needMaskingText(n, maskTextClass, maskTextSelector) &&
                  textContent) {
                  textContent = maskTextFn
                      ? maskTextFn(textContent)
                      : textContent.replace(/[\S]/g, '*');
              }
              return {
                  type: exports.NodeType.Text,
                  textContent: textContent || '',
                  isStyle: isStyle,
                  rootId: rootId,
              };
          case n.CDATA_SECTION_NODE:
              return {
                  type: exports.NodeType.CDATA,
                  textContent: '',
                  rootId: rootId,
              };
          case n.COMMENT_NODE:
              return {
                  type: exports.NodeType.Comment,
                  textContent: n.textContent || '',
                  rootId: rootId,
              };
          default:
              return false;
      }
  }
  function lowerIfExists(maybeAttr) {
      if (maybeAttr === undefined) {
          return '';
      }
      else {
          return maybeAttr.toLowerCase();
      }
  }
  function slimDOMExcluded(sn, slimDOMOptions) {
      if (slimDOMOptions.comment && sn.type === exports.NodeType.Comment) {
          return true;
      }
      else if (sn.type === exports.NodeType.Element) {
          if (slimDOMOptions.script &&
              (sn.tagName === 'script' ||
                  (sn.tagName === 'link' &&
                      sn.attributes.rel === 'preload' &&
                      sn.attributes.as === 'script') ||
                  (sn.tagName === 'link' &&
                      sn.attributes.rel === 'prefetch' &&
                      typeof sn.attributes.href === 'string' &&
                      sn.attributes.href.endsWith('.js')))) {
              return true;
          }
          else if (slimDOMOptions.headFavicon &&
              ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||
                  (sn.tagName === 'meta' &&
                      (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||
                          lowerIfExists(sn.attributes.name) === 'application-name' ||
                          lowerIfExists(sn.attributes.rel) === 'icon' ||
                          lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||
                          lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {
              return true;
          }
          else if (sn.tagName === 'meta') {
              if (slimDOMOptions.headMetaDescKeywords &&
                  lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
                  return true;
              }
              else if (slimDOMOptions.headMetaSocial &&
                  (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||
                      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||
                      lowerIfExists(sn.attributes.name) === 'pinterest')) {
                  return true;
              }
              else if (slimDOMOptions.headMetaRobots &&
                  (lowerIfExists(sn.attributes.name) === 'robots' ||
                      lowerIfExists(sn.attributes.name) === 'googlebot' ||
                      lowerIfExists(sn.attributes.name) === 'bingbot')) {
                  return true;
              }
              else if (slimDOMOptions.headMetaHttpEquiv &&
                  sn.attributes['http-equiv'] !== undefined) {
                  return true;
              }
              else if (slimDOMOptions.headMetaAuthorship &&
                  (lowerIfExists(sn.attributes.name) === 'author' ||
                      lowerIfExists(sn.attributes.name) === 'generator' ||
                      lowerIfExists(sn.attributes.name) === 'framework' ||
                      lowerIfExists(sn.attributes.name) === 'publisher' ||
                      lowerIfExists(sn.attributes.name) === 'progid' ||
                      lowerIfExists(sn.attributes.property).match(/^article:/) ||
                      lowerIfExists(sn.attributes.property).match(/^product:/))) {
                  return true;
              }
              else if (slimDOMOptions.headMetaVerification &&
                  (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||
                      lowerIfExists(sn.attributes.name) === 'yandex-verification' ||
                      lowerIfExists(sn.attributes.name) === 'csrf-token' ||
                      lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||
                      lowerIfExists(sn.attributes.name) === 'verify-v1' ||
                      lowerIfExists(sn.attributes.name) === 'verification' ||
                      lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {
                  return true;
              }
          }
      }
      return false;
  }
  function serializeNodeWithId(n, options) {
      var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.recordCanvas, recordCanvas = _d === void 0 ? false : _d, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _e = options.iframeLoadTimeout, iframeLoadTimeout = _e === void 0 ? 5000 : _e, _f = options.keepIframeSrcFn, keepIframeSrcFn = _f === void 0 ? function () { return false; } : _f;
      var _g = options.preserveWhiteSpace, preserveWhiteSpace = _g === void 0 ? true : _g;
      var _serializedNode = serializeNode(n, {
          doc: doc,
          blockClass: blockClass,
          blockSelector: blockSelector,
          maskTextClass: maskTextClass,
          maskTextSelector: maskTextSelector,
          inlineStylesheet: inlineStylesheet,
          maskInputOptions: maskInputOptions,
          maskTextFn: maskTextFn,
          maskInputFn: maskInputFn,
          recordCanvas: recordCanvas,
          keepIframeSrcFn: keepIframeSrcFn,
      });
      if (!_serializedNode) {
          console.warn(n, 'not serialized');
          return null;
      }
      var id;
      if ('__sn' in n) {
          id = n.__sn.id;
      }
      else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||
          (!preserveWhiteSpace &&
              _serializedNode.type === exports.NodeType.Text &&
              !_serializedNode.isStyle &&
              !_serializedNode.textContent.replace(/^\s+|\s+$/gm, '').length)) {
          id = IGNORED_NODE;
      }
      else {
          id = genId();
      }
      var serializedNode = Object.assign(_serializedNode, { id: id });
      n.__sn = serializedNode;
      if (id === IGNORED_NODE) {
          return null;
      }
      map[id] = n;
      if (onSerialize) {
          onSerialize(n);
      }
      var recordChild = !skipChild;
      if (serializedNode.type === exports.NodeType.Element) {
          recordChild = recordChild && !serializedNode.needBlock;
          delete serializedNode.needBlock;
      }
      if ((serializedNode.type === exports.NodeType.Document ||
          serializedNode.type === exports.NodeType.Element) &&
          recordChild) {
          if (slimDOMOptions.headWhitespace &&
              _serializedNode.type === exports.NodeType.Element &&
              _serializedNode.tagName === 'head') {
              preserveWhiteSpace = false;
          }
          var bypassOptions = {
              doc: doc,
              map: map,
              blockClass: blockClass,
              blockSelector: blockSelector,
              maskTextClass: maskTextClass,
              maskTextSelector: maskTextSelector,
              skipChild: skipChild,
              inlineStylesheet: inlineStylesheet,
              maskInputOptions: maskInputOptions,
              maskTextFn: maskTextFn,
              maskInputFn: maskInputFn,
              slimDOMOptions: slimDOMOptions,
              recordCanvas: recordCanvas,
              preserveWhiteSpace: preserveWhiteSpace,
              onSerialize: onSerialize,
              onIframeLoad: onIframeLoad,
              iframeLoadTimeout: iframeLoadTimeout,
              keepIframeSrcFn: keepIframeSrcFn,
          };
          for (var _i = 0, _h = Array.from(n.childNodes); _i < _h.length; _i++) {
              var childN = _h[_i];
              var serializedChildNode = serializeNodeWithId(childN, bypassOptions);
              if (serializedChildNode) {
                  serializedNode.childNodes.push(serializedChildNode);
              }
          }
          if (isElement(n) && n.shadowRoot) {
              serializedNode.isShadowHost = true;
              for (var _j = 0, _k = Array.from(n.shadowRoot.childNodes); _j < _k.length; _j++) {
                  var childN = _k[_j];
                  var serializedChildNode = serializeNodeWithId(childN, bypassOptions);
                  if (serializedChildNode) {
                      serializedChildNode.isShadow = true;
                      serializedNode.childNodes.push(serializedChildNode);
                  }
              }
          }
      }
      if (n.parentNode && isShadowRoot(n.parentNode)) {
          serializedNode.isShadow = true;
      }
      if (serializedNode.type === exports.NodeType.Element &&
          serializedNode.tagName === 'iframe') {
          onceIframeLoaded(n, function () {
              var iframeDoc = n.contentDocument;
              if (iframeDoc && onIframeLoad) {
                  var serializedIframeNode = serializeNodeWithId(iframeDoc, {
                      doc: iframeDoc,
                      map: map,
                      blockClass: blockClass,
                      blockSelector: blockSelector,
                      maskTextClass: maskTextClass,
                      maskTextSelector: maskTextSelector,
                      skipChild: false,
                      inlineStylesheet: inlineStylesheet,
                      maskInputOptions: maskInputOptions,
                      maskTextFn: maskTextFn,
                      maskInputFn: maskInputFn,
                      slimDOMOptions: slimDOMOptions,
                      recordCanvas: recordCanvas,
                      preserveWhiteSpace: preserveWhiteSpace,
                      onSerialize: onSerialize,
                      onIframeLoad: onIframeLoad,
                      iframeLoadTimeout: iframeLoadTimeout,
                      keepIframeSrcFn: keepIframeSrcFn,
                  });
                  if (serializedIframeNode) {
                      onIframeLoad(n, serializedIframeNode);
                  }
              }
          }, iframeLoadTimeout);
      }
      return serializedNode;
  }
  function snapshot(n, options) {
      var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.recordCanvas, recordCanvas = _g === void 0 ? false : _g, _h = _a.maskAllInputs, maskAllInputs = _h === void 0 ? false : _h, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _j = _a.slimDOM, slimDOM = _j === void 0 ? false : _j, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _k = _a.keepIframeSrcFn, keepIframeSrcFn = _k === void 0 ? function () { return false; } : _k;
      var idNodeMap = {};
      var maskInputOptions = maskAllInputs === true
          ? {
              color: true,
              date: true,
              'datetime-local': true,
              email: true,
              month: true,
              number: true,
              range: true,
              search: true,
              tel: true,
              text: true,
              time: true,
              url: true,
              week: true,
              textarea: true,
              select: true,
              password: true,
          }
          : maskAllInputs === false
              ? {
                  password: true,
              }
              : maskAllInputs;
      var slimDOMOptions = slimDOM === true || slimDOM === 'all'
          ?
              {
                  script: true,
                  comment: true,
                  headFavicon: true,
                  headWhitespace: true,
                  headMetaDescKeywords: slimDOM === 'all',
                  headMetaSocial: true,
                  headMetaRobots: true,
                  headMetaHttpEquiv: true,
                  headMetaAuthorship: true,
                  headMetaVerification: true,
              }
          : slimDOM === false
              ? {}
              : slimDOM;
      return [
          serializeNodeWithId(n, {
              doc: n,
              map: idNodeMap,
              blockClass: blockClass,
              blockSelector: blockSelector,
              maskTextClass: maskTextClass,
              maskTextSelector: maskTextSelector,
              skipChild: false,
              inlineStylesheet: inlineStylesheet,
              maskInputOptions: maskInputOptions,
              maskTextFn: maskTextFn,
              maskInputFn: maskInputFn,
              slimDOMOptions: slimDOMOptions,
              recordCanvas: recordCanvas,
              preserveWhiteSpace: preserveWhiteSpace,
              onSerialize: onSerialize,
              onIframeLoad: onIframeLoad,
              iframeLoadTimeout: iframeLoadTimeout,
              keepIframeSrcFn: keepIframeSrcFn,
          }),
          idNodeMap,
      ];
  }
  function visitSnapshot(node, onVisit) {
      function walk(current) {
          onVisit(current);
          if (current.type === exports.NodeType.Document ||
              current.type === exports.NodeType.Element) {
              current.childNodes.forEach(walk);
          }
      }
      walk(node);
  }
  function cleanupSnapshot() {
      _id = 1;
  }

  var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
  function parse(css, options) {
      if (options === void 0) { options = {}; }
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
          var lines = str.match(/\n/g);
          if (lines) {
              lineno += lines.length;
          }
          var i = str.lastIndexOf('\n');
          column = i === -1 ? column + str.length : str.length - i;
      }
      function position() {
          var start = { line: lineno, column: column };
          return function (node) {
              node.position = new Position(start);
              whitespace();
              return node;
          };
      }
      var Position = (function () {
          function Position(start) {
              this.start = start;
              this.end = { line: lineno, column: column };
              this.source = options.source;
          }
          return Position;
      }());
      Position.prototype.content = css;
      var errorsList = [];
      function error(msg) {
          var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
          err.reason = msg;
          err.filename = options.source;
          err.line = lineno;
          err.column = column;
          err.source = css;
          if (options.silent) {
              errorsList.push(err);
          }
          else {
              throw err;
          }
      }
      function stylesheet() {
          var rulesList = rules();
          return {
              type: 'stylesheet',
              stylesheet: {
                  source: options.source,
                  rules: rulesList,
                  parsingErrors: errorsList,
              },
          };
      }
      function open() {
          return match(/^{\s*/);
      }
      function close() {
          return match(/^}/);
      }
      function rules() {
          var node;
          var rules = [];
          whitespace();
          comments(rules);
          while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
              if (node !== false) {
                  rules.push(node);
                  comments(rules);
              }
          }
          return rules;
      }
      function match(re) {
          var m = re.exec(css);
          if (!m) {
              return;
          }
          var str = m[0];
          updatePosition(str);
          css = css.slice(str.length);
          return m;
      }
      function whitespace() {
          match(/^\s*/);
      }
      function comments(rules) {
          if (rules === void 0) { rules = []; }
          var c;
          while ((c = comment())) {
              if (c !== false) {
                  rules.push(c);
              }
              c = comment();
          }
          return rules;
      }
      function comment() {
          var pos = position();
          if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
              return;
          }
          var i = 2;
          while ('' !== css.charAt(i) &&
              ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {
              ++i;
          }
          i += 2;
          if ('' === css.charAt(i - 1)) {
              return error('End of comment missing');
          }
          var str = css.slice(2, i - 2);
          column += 2;
          updatePosition(str);
          css = css.slice(i);
          column += 2;
          return pos({
              type: 'comment',
              comment: str,
          });
      }
      function selector() {
          var m = match(/^([^{]+)/);
          if (!m) {
              return;
          }
          return trim(m[0])
              .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
              .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
              return m.replace(/,/g, '\u200C');
          })
              .split(/\s*(?![^(]*\)),\s*/)
              .map(function (s) {
              return s.replace(/\u200C/g, ',');
          });
      }
      function declaration() {
          var pos = position();
          var propMatch = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
          if (!propMatch) {
              return;
          }
          var prop = trim(propMatch[0]);
          if (!match(/^:\s*/)) {
              return error("property missing ':'");
          }
          var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
          var ret = pos({
              type: 'declaration',
              property: prop.replace(commentre, ''),
              value: val ? trim(val[0]).replace(commentre, '') : '',
          });
          match(/^[;\s]*/);
          return ret;
      }
      function declarations() {
          var decls = [];
          if (!open()) {
              return error("missing '{'");
          }
          comments(decls);
          var decl;
          while ((decl = declaration())) {
              if (decl !== false) {
                  decls.push(decl);
                  comments(decls);
              }
              decl = declaration();
          }
          if (!close()) {
              return error("missing '}'");
          }
          return decls;
      }
      function keyframe() {
          var m;
          var vals = [];
          var pos = position();
          while ((m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/))) {
              vals.push(m[1]);
              match(/^,\s*/);
          }
          if (!vals.length) {
              return;
          }
          return pos({
              type: 'keyframe',
              values: vals,
              declarations: declarations(),
          });
      }
      function atkeyframes() {
          var pos = position();
          var m = match(/^@([-\w]+)?keyframes\s*/);
          if (!m) {
              return;
          }
          var vendor = m[1];
          m = match(/^([-\w]+)\s*/);
          if (!m) {
              return error('@keyframes missing name');
          }
          var name = m[1];
          if (!open()) {
              return error("@keyframes missing '{'");
          }
          var frame;
          var frames = comments();
          while ((frame = keyframe())) {
              frames.push(frame);
              frames = frames.concat(comments());
          }
          if (!close()) {
              return error("@keyframes missing '}'");
          }
          return pos({
              type: 'keyframes',
              name: name,
              vendor: vendor,
              keyframes: frames,
          });
      }
      function atsupports() {
          var pos = position();
          var m = match(/^@supports *([^{]+)/);
          if (!m) {
              return;
          }
          var supports = trim(m[1]);
          if (!open()) {
              return error("@supports missing '{'");
          }
          var style = comments().concat(rules());
          if (!close()) {
              return error("@supports missing '}'");
          }
          return pos({
              type: 'supports',
              supports: supports,
              rules: style,
          });
      }
      function athost() {
          var pos = position();
          var m = match(/^@host\s*/);
          if (!m) {
              return;
          }
          if (!open()) {
              return error("@host missing '{'");
          }
          var style = comments().concat(rules());
          if (!close()) {
              return error("@host missing '}'");
          }
          return pos({
              type: 'host',
              rules: style,
          });
      }
      function atmedia() {
          var pos = position();
          var m = match(/^@media *([^{]+)/);
          if (!m) {
              return;
          }
          var media = trim(m[1]);
          if (!open()) {
              return error("@media missing '{'");
          }
          var style = comments().concat(rules());
          if (!close()) {
              return error("@media missing '}'");
          }
          return pos({
              type: 'media',
              media: media,
              rules: style,
          });
      }
      function atcustommedia() {
          var pos = position();
          var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
          if (!m) {
              return;
          }
          return pos({
              type: 'custom-media',
              name: trim(m[1]),
              media: trim(m[2]),
          });
      }
      function atpage() {
          var pos = position();
          var m = match(/^@page */);
          if (!m) {
              return;
          }
          var sel = selector() || [];
          if (!open()) {
              return error("@page missing '{'");
          }
          var decls = comments();
          var decl;
          while ((decl = declaration())) {
              decls.push(decl);
              decls = decls.concat(comments());
          }
          if (!close()) {
              return error("@page missing '}'");
          }
          return pos({
              type: 'page',
              selectors: sel,
              declarations: decls,
          });
      }
      function atdocument() {
          var pos = position();
          var m = match(/^@([-\w]+)?document *([^{]+)/);
          if (!m) {
              return;
          }
          var vendor = trim(m[1]);
          var doc = trim(m[2]);
          if (!open()) {
              return error("@document missing '{'");
          }
          var style = comments().concat(rules());
          if (!close()) {
              return error("@document missing '}'");
          }
          return pos({
              type: 'document',
              document: doc,
              vendor: vendor,
              rules: style,
          });
      }
      function atfontface() {
          var pos = position();
          var m = match(/^@font-face\s*/);
          if (!m) {
              return;
          }
          if (!open()) {
              return error("@font-face missing '{'");
          }
          var decls = comments();
          var decl;
          while ((decl = declaration())) {
              decls.push(decl);
              decls = decls.concat(comments());
          }
          if (!close()) {
              return error("@font-face missing '}'");
          }
          return pos({
              type: 'font-face',
              declarations: decls,
          });
      }
      var atimport = _compileAtrule('import');
      var atcharset = _compileAtrule('charset');
      var atnamespace = _compileAtrule('namespace');
      function _compileAtrule(name) {
          var re = new RegExp('^@' + name + '\\s*([^;]+);');
          return function () {
              var pos = position();
              var m = match(re);
              if (!m) {
                  return;
              }
              var ret = { type: name };
              ret[name] = m[1].trim();
              return pos(ret);
          };
      }
      function atrule() {
          if (css[0] !== '@') {
              return;
          }
          return (atkeyframes() ||
              atmedia() ||
              atcustommedia() ||
              atsupports() ||
              atimport() ||
              atcharset() ||
              atnamespace() ||
              atdocument() ||
              atpage() ||
              athost() ||
              atfontface());
      }
      function rule() {
          var pos = position();
          var sel = selector();
          if (!sel) {
              return error('selector missing');
          }
          comments();
          return pos({
              type: 'rule',
              selectors: sel,
              declarations: declarations(),
          });
      }
      return addParent(stylesheet());
  }
  function trim(str) {
      return str ? str.replace(/^\s+|\s+$/g, '') : '';
  }
  function addParent(obj, parent) {
      var isNode = obj && typeof obj.type === 'string';
      var childParent = isNode ? obj : parent;
      for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
          var k = _a[_i];
          var value = obj[k];
          if (Array.isArray(value)) {
              value.forEach(function (v) {
                  addParent(v, childParent);
              });
          }
          else if (value && typeof value === 'object') {
              addParent(value, childParent);
          }
      }
      if (isNode) {
          Object.defineProperty(obj, 'parent', {
              configurable: true,
              writable: true,
              enumerable: false,
              value: parent || null,
          });
      }
      return obj;
  }

  var tagMap = {
      script: 'noscript',
      altglyph: 'altGlyph',
      altglyphdef: 'altGlyphDef',
      altglyphitem: 'altGlyphItem',
      animatecolor: 'animateColor',
      animatemotion: 'animateMotion',
      animatetransform: 'animateTransform',
      clippath: 'clipPath',
      feblend: 'feBlend',
      fecolormatrix: 'feColorMatrix',
      fecomponenttransfer: 'feComponentTransfer',
      fecomposite: 'feComposite',
      feconvolvematrix: 'feConvolveMatrix',
      fediffuselighting: 'feDiffuseLighting',
      fedisplacementmap: 'feDisplacementMap',
      fedistantlight: 'feDistantLight',
      fedropshadow: 'feDropShadow',
      feflood: 'feFlood',
      fefunca: 'feFuncA',
      fefuncb: 'feFuncB',
      fefuncg: 'feFuncG',
      fefuncr: 'feFuncR',
      fegaussianblur: 'feGaussianBlur',
      feimage: 'feImage',
      femerge: 'feMerge',
      femergenode: 'feMergeNode',
      femorphology: 'feMorphology',
      feoffset: 'feOffset',
      fepointlight: 'fePointLight',
      fespecularlighting: 'feSpecularLighting',
      fespotlight: 'feSpotLight',
      fetile: 'feTile',
      feturbulence: 'feTurbulence',
      foreignobject: 'foreignObject',
      glyphref: 'glyphRef',
      lineargradient: 'linearGradient',
      radialgradient: 'radialGradient',
  };
  function getTagName(n) {
      var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;
      if (tagName === 'link' && n.attributes._cssText) {
          tagName = 'style';
      }
      return tagName;
  }
  function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
  var HOVER_SELECTOR = /([^\\]):hover/;
  var HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR, 'g');
  function addHoverClass(cssText) {
      var ast = parse(cssText, {
          silent: true,
      });
      if (!ast.stylesheet) {
          return cssText;
      }
      var selectors = [];
      ast.stylesheet.rules.forEach(function (rule) {
          if ('selectors' in rule) {
              (rule.selectors || []).forEach(function (selector) {
                  if (HOVER_SELECTOR.test(selector)) {
                      selectors.push(selector);
                  }
              });
          }
      });
      if (selectors.length === 0) {
          return cssText;
      }
      var selectorMatcher = new RegExp(selectors
          .filter(function (selector, index) { return selectors.indexOf(selector) === index; })
          .sort(function (a, b) { return b.length - a.length; })
          .map(function (selector) {
          return escapeRegExp(selector);
      })
          .join('|'), 'g');
      return cssText.replace(selectorMatcher, function (selector) {
          var newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\:hover');
          return selector + ", " + newSelector;
      });
  }
  function buildNode(n, options) {
      var doc = options.doc, hackCss = options.hackCss;
      switch (n.type) {
          case exports.NodeType.Document:
              return doc.implementation.createDocument(null, '', null);
          case exports.NodeType.DocumentType:
              return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);
          case exports.NodeType.Element:
              var tagName = getTagName(n);
              var node_1;
              if (n.isSVG) {
                  node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);
              }
              else {
                  node_1 = doc.createElement(tagName);
              }
              var _loop_1 = function (name) {
                  if (!n.attributes.hasOwnProperty(name)) {
                      return "continue";
                  }
                  var value = n.attributes[name];
                  value =
                      typeof value === 'boolean' || typeof value === 'number' ? '' : value;
                  if (!name.startsWith('rr_')) {
                      var isTextarea = tagName === 'textarea' && name === 'value';
                      var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';
                      if (isRemoteOrDynamicCss && hackCss) {
                          value = addHoverClass(value);
                      }
                      if (isTextarea || isRemoteOrDynamicCss) {
                          var child = doc.createTextNode(value);
                          for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {
                              var c = _a[_i];
                              if (c.nodeType === node_1.TEXT_NODE) {
                                  node_1.removeChild(c);
                              }
                          }
                          node_1.appendChild(child);
                          return "continue";
                      }
                      try {
                          if (n.isSVG && name === 'xlink:href') {
                              node_1.setAttributeNS('http://www.w3.org/1999/xlink', name, value);
                          }
                          else if (name === 'onload' ||
                              name === 'onclick' ||
                              name.substring(0, 7) === 'onmouse') {
                              node_1.setAttribute('_' + name, value);
                          }
                          else if (tagName === 'meta' &&
                              n.attributes['http-equiv'] === 'Content-Security-Policy' &&
                              name === 'content') {
                              node_1.setAttribute('csp-content', value);
                              return "continue";
                          }
                          else if (tagName === 'link' &&
                              n.attributes.rel === 'preload' &&
                              n.attributes.as === 'script') ;
                          else if (tagName === 'link' &&
                              n.attributes.rel === 'prefetch' &&
                              typeof n.attributes.href === 'string' &&
                              n.attributes.href.endsWith('.js')) ;
                          else {
                              node_1.setAttribute(name, value);
                          }
                      }
                      catch (error) {
                      }
                  }
                  else {
                      if (tagName === 'canvas' && name === 'rr_dataURL') {
                          var image_1 = document.createElement('img');
                          image_1.src = value;
                          image_1.onload = function () {
                              var ctx = node_1.getContext('2d');
                              if (ctx) {
                                  ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);
                              }
                          };
                      }
                      if (name === 'rr_width') {
                          node_1.style.width = value;
                      }
                      if (name === 'rr_height') {
                          node_1.style.height = value;
                      }
                      if (name === 'rr_mediaCurrentTime') {
                          node_1.currentTime = n.attributes
                              .rr_mediaCurrentTime;
                      }
                      if (name === 'rr_mediaState') {
                          switch (value) {
                              case 'played':
                                  node_1
                                      .play()
                                      .catch(function (e) { return console.warn('media playback error', e); });
                                  break;
                              case 'paused':
                                  node_1.pause();
                                  break;
                              default:
                          }
                      }
                  }
              };
              for (var name in n.attributes) {
                  _loop_1(name);
              }
              if (n.isShadowHost) {
                  if (!node_1.shadowRoot) {
                      node_1.attachShadow({ mode: 'open' });
                  }
                  else {
                      while (node_1.shadowRoot.firstChild) {
                          node_1.shadowRoot.removeChild(node_1.shadowRoot.firstChild);
                      }
                  }
              }
              return node_1;
          case exports.NodeType.Text:
              return doc.createTextNode(n.isStyle && hackCss ? addHoverClass(n.textContent) : n.textContent);
          case exports.NodeType.CDATA:
              return doc.createCDATASection(n.textContent);
          case exports.NodeType.Comment:
              return doc.createComment(n.textContent);
          default:
              return null;
      }
  }
  function buildNodeWithSN(n, options) {
      var doc = options.doc, map = options.map, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.hackCss, hackCss = _b === void 0 ? true : _b, afterAppend = options.afterAppend;
      var node = buildNode(n, { doc: doc, hackCss: hackCss });
      if (!node) {
          return null;
      }
      if (n.rootId) {
          console.assert(map[n.rootId] === doc, 'Target document should has the same root id.');
      }
      if (n.type === exports.NodeType.Document) {
          doc.close();
          doc.open();
          node = doc;
      }
      node.__sn = n;
      map[n.id] = node;
      if ((n.type === exports.NodeType.Document || n.type === exports.NodeType.Element) &&
          !skipChild) {
          for (var _i = 0, _c = n.childNodes; _i < _c.length; _i++) {
              var childN = _c[_i];
              var childNode = buildNodeWithSN(childN, {
                  doc: doc,
                  map: map,
                  skipChild: false,
                  hackCss: hackCss,
                  afterAppend: afterAppend,
              });
              if (!childNode) {
                  console.warn('Failed to rebuild', childN);
                  continue;
              }
              if (childN.isShadow && isElement(node) && node.shadowRoot) {
                  node.shadowRoot.appendChild(childNode);
              }
              else {
                  node.appendChild(childNode);
              }
              if (afterAppend) {
                  afterAppend(childNode);
              }
          }
      }
      return node;
  }
  function visit(idNodeMap, onVisit) {
      function walk(node) {
          onVisit(node);
      }
      for (var key in idNodeMap) {
          if (idNodeMap[key]) {
              walk(idNodeMap[key]);
          }
      }
  }
  function handleScroll(node) {
      var n = node.__sn;
      if (n.type !== exports.NodeType.Element) {
          return;
      }
      var el = node;
      for (var name in n.attributes) {
          if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {
              continue;
          }
          var value = n.attributes[name];
          if (name === 'rr_scrollLeft') {
              el.scrollLeft = value;
          }
          if (name === 'rr_scrollTop') {
              el.scrollTop = value;
          }
      }
  }
  function rebuild(n, options) {
      var doc = options.doc, onVisit = options.onVisit, _a = options.hackCss, hackCss = _a === void 0 ? true : _a, afterAppend = options.afterAppend;
      var idNodeMap = {};
      var node = buildNodeWithSN(n, {
          doc: doc,
          map: idNodeMap,
          skipChild: false,
          hackCss: hackCss,
          afterAppend: afterAppend,
      });
      visit(idNodeMap, function (visitedNode) {
          if (onVisit) {
              onVisit(visitedNode);
          }
          handleScroll(visitedNode);
      });
      return [node, idNodeMap];
  }

  exports.snapshot = snapshot;
  exports.serializeNodeWithId = serializeNodeWithId;
  exports.rebuild = rebuild;
  exports.buildNodeWithSN = buildNodeWithSN;
  exports.addHoverClass = addHoverClass;
  exports.transformAttribute = transformAttribute;
  exports.visitSnapshot = visitSnapshot;
  exports.cleanupSnapshot = cleanupSnapshot;
  exports.needMaskingText = needMaskingText;
  exports.IGNORED_NODE = IGNORED_NODE;
  exports.isElement = isElement;
  exports.isShadowRoot = isShadowRoot;
  exports.maskInputValue = maskInputValue;

  return exports;

}({}));
