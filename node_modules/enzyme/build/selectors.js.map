{"version":3,"sources":["../src/selectors.js"],"names":["buildPredicate","reduceTreeBySelector","reduceTreesBySelector","parser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","arr","Set","uniqueReduce","fn","nodes","reduce","safelyGenerateTokens","selector","parse","err","Error","matchAttributeSelector","node","token","operator","value","name","nodeProps","descriptor","Object","getOwnPropertyDescriptor","get","nodePropValue","type","split","indexOf","startsWith","slice","length","matchPseudoSelector","root","parameters","every","n","rendered","firstChild","document","adapter","activeElement","nodeToHostNode","TypeError","nodeMatchesToken","buildPredicateFromToken","body","bodyToken","isComplexSelector","tokens","some","isElementType","isValidElementType","matchesElementType","Array","isArray","keys","hasUndefinedValues","matchAdjacentSiblings","predicate","matches","parent","parentChildren","nodeIndex","adjacentSibling","push","matchGeneralSibling","youngerSiblings","concat","filter","matchDirectChild","matchDescendant","map","childrenOfNode","elements","x","tag","results","index","roots"],"mappings":"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","file":"selectors.js","sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport has from 'has';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return has(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"]}