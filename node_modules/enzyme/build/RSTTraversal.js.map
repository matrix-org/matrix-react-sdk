{"version":3,"sources":["../src/RSTTraversal.js"],"names":["propsOfNode","childrenOfNode","hasClassName","treeForEach","treeFilter","findParentNode","pathToNode","parentsOfNode","nodeHasId","nodeMatchesObjectProps","getTextFromNode","getTextFromHostNodes","getHTMLFromHostNodes","node","props","adapter","adapterHasIsFragment","isFragment","renderedArray","Array","isArray","rendered","map","currentChild","className","classes","String","replace","test","indexOf","tree","fn","forEach","results","push","root","targetNode","pathFilter","path","filter","length","queue","hasNode","testNode","current","pop","children","reverse","id","CAN_NEVER_MATCH","replaceUndefined","v","replaceUndefinedValues","obj","reduce","acc","k","getTextFromHostNode","hostNode","textContent","getTextFromRSTNode","getCustom","handleHostNodes","recurse","nullRenderReturnsNull","type","nodeType","join","displayName","item","nodes","concat","nodeToHostNode","getHTMLFromHostNode","outerHTML"],"mappings":"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","file":"RSTTraversal.js","sourcesContent":["import flat from 'array.prototype.flat';\nimport entries from 'object.entries';\nimport isSubset from 'is-subset';\nimport functionName from 'function.prototype.name';\nimport isRegex from 'is-regex';\nimport getAdapter from './getAdapter';\n\nexport function propsOfNode(node) {\n  return (node && node.props) || {};\n}\n\nexport function childrenOfNode(node) {\n  if (!node) return [];\n\n  const adapter = getAdapter();\n  const adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  const renderedArray = Array.isArray(node.rendered) ? flat(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return flat(renderedArray.map((currentChild) => {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nexport function hasClassName(node, className) {\n  let classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if (isRegex(className)) return className.test(classes);\n  return ` ${classes} `.indexOf(` ${className} `) > -1;\n}\n\nexport function treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach((node) => treeForEach(node, fn));\n}\n\nexport function treeFilter(tree, fn) {\n  const results = [];\n  treeForEach(tree, (node) => {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nexport function findParentNode(root, targetNode) {\n  const results = treeFilter(\n    root,\n    (node) => {\n      if (!node.rendered) {\n        return false;\n      }\n\n      return childrenOfNode(node).indexOf(targetNode) !== -1;\n    },\n  );\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter((tree) => treeFilter(tree, fn).length !== 0);\n}\n\nexport function pathToNode(node, root) {\n  const queue = [root];\n  const path = [];\n\n  const hasNode = (testNode) => node === testNode;\n\n  while (queue.length) {\n    const current = queue.pop();\n    const children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push(...children);\n  }\n\n  return null;\n}\n\nexport function parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nexport function nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nconst CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return entries(obj)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: replaceUndefined(v) }), {});\n}\n\nexport function nodeMatchesObjectProps(node, props) {\n  return isSubset(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, {\n  getCustom,\n  handleHostNodes,\n  recurse,\n  nullRenderReturnsNull = false,\n}) {\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nexport function getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom({ type }) {\n      return `<${type.displayName || functionName(type)} />`;\n    },\n  });\n}\n\nexport function getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getTextFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getTextFromHostNode).join('');\n    },\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nexport function getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getHTMLFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getHTMLFromHostNode).join('');\n    },\n    nullRenderReturnsNull: true,\n  });\n}\n"]}