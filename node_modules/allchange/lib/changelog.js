"use strict";
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateChangelog = exports.makeChangeEntry = exports.bugFixChangeHeader = exports.featureChangeHeader = exports.deprecationsHeader = exports.breakingChangeHeader = exports.securityFixHeader = void 0;
const changes_1 = require("./changes");
const projects_1 = require("./projects");
const issue_1 = require("./issue");
const semver_1 = __importDefault(require("semver"));
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const readline_1 = __importDefault(require("readline"));
const path_1 = __importDefault(require("path"));
const loglevel_1 = __importDefault(require("loglevel"));
exports.securityFixHeader = '## \uD83D\uDD12 SECURITY FIXES';
exports.breakingChangeHeader = '## \uD83D\uDEA8 BREAKING CHANGES';
exports.deprecationsHeader = '## \uD83E\uDD96 Deprecations';
exports.featureChangeHeader = '## \u2728 Features';
exports.bugFixChangeHeader = '## \uD83D\uDC1B Bug Fixes';
function readChangelog(project) {
    return __asyncGenerator(this, arguments, function* readChangelog_1() {
        var e_1, _a;
        const fp = fs_1.default.createReadStream(path_1.default.join(project.dir, 'CHANGELOG.md'));
        const rl = readline_1.default.createInterface(fp);
        let version;
        let fullText = '';
        try {
            for (var rl_1 = __asyncValues(rl), rl_1_1; rl_1_1 = yield __await(rl_1.next()), !rl_1_1.done;) {
                const line = rl_1_1.value;
                const matches = /^Changes in \[([\d\w.-]+)\]/.exec(line);
                if (matches) {
                    if (version) {
                        yield yield __await({
                            version,
                            text: fullText,
                        });
                    }
                    version = 'v' + matches[1];
                    fullText = '';
                }
                if (version)
                    fullText += line + "\n";
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rl_1_1 && !rl_1_1.done && (_a = rl_1.return)) yield __await(_a.call(rl_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (version) {
            yield yield __await({
                version,
                text: fullText,
            });
        }
    });
}
// A really simple markdown sanitiser to prevent entries where someone's
// used a rogue asterisk from making things silly
// Actually github's markdown formatter handles this perfectly sensibly,
// but it does send the vim syntax highlihter into meltdown (although what doesn't?)
// Just check that there's an even number of certain nonescaped chars, and if not,
// escape them
function sanitiseMarkdown(text) {
    const specialChars = {
        '*': 0,
        // shall we do the others? let's just start with this one
    };
    const iterChars = (t, fn) => {
        let escape = false;
        for (let i = 0; i < t.length; ++i) {
            fn(t[i], escape);
            escape = t[i] == '\\';
        }
    };
    iterChars(text, (c, escape) => {
        if (!escape && Object.keys(specialChars).includes(c)) {
            ++specialChars[c];
        }
    });
    for (const [special, count] of Object.entries(specialChars)) {
        if (count % 2) {
            let newText = '';
            iterChars(text, (c, escape) => {
                if (c === special && !escape) {
                    newText += '\\' + c;
                }
                else {
                    newText += c;
                }
            });
            text = newText;
        }
    }
    return text;
}
function engJoin(things) {
    if (things.length === 1)
        return things[0];
    const firstLot = things.slice(0, things.length - 2);
    const lastTwo = things.slice(things.length - 2);
    let result = '';
    if (firstLot.length) {
        result = firstLot.join(', ') + ' ';
    }
    result += lastTwo.join(' and ');
    return result;
}
function makeChangeEntry(change, forProject) {
    let line = '';
    line += ` * ${sanitiseMarkdown(projects_1.getChangeNotes(change, forProject.name))}`;
    line += ` ([\\#${change.pr.number}](${change.pr.html_url})).`;
    if (change.fixes.length > 0) {
        const fixesString = engJoin(change.fixes.map(c => issue_1.formatIssue(c, forProject.owner, forProject.repo)));
        line += ` Fixes ${fixesString}.`;
    }
    if (!['MEMBER', 'OWNER'].includes(change.pr.author_association)) {
        line += ` Contributed by @${change.pr.user.login}.`;
    }
    return line;
}
exports.makeChangeEntry = makeChangeEntry;
function makeChangelogEntry(changes, version, forProject) {
    const formattedVersion = semver_1.default.parse(version).format(); // easy way of removing the leading 'v'
    const now = new Date();
    const lines = [];
    const padTwo = n => String(n).padStart(2, '0');
    lines.push(`Changes in ` +
        `[${formattedVersion}]` +
        `(https://github.com/${forProject.owner}/${forProject.repo}/releases/tag/v${formattedVersion}) ` +
        `(${now.getFullYear()}-${padTwo(now.getMonth() + 1)}-${padTwo(now.getDate())})`);
    lines.push('='.repeat(lines[0].length));
    lines.push('');
    const shouldInclude = changes.filter(c => c.shouldInclude);
    const breaking = shouldInclude.filter(c => c.breaking);
    const security = shouldInclude.filter(c => c.security);
    const others = shouldInclude.filter(c => !c.breaking && !c.security);
    const deprecations = others.filter(c => c.changeType == changes_1.ChangeType.DEPRECATION);
    const features = others.filter(c => c.changeType == changes_1.ChangeType.FEATURE);
    const bugfixes = others.filter(c => c.changeType == changes_1.ChangeType.BUGFIX);
    if (security.length > 0) {
        lines.push(exports.securityFixHeader);
        for (const change of security) {
            lines.push(makeChangeEntry(change, forProject));
        }
        lines.push('');
    }
    if (breaking.length > 0) {
        lines.push(exports.breakingChangeHeader);
        for (const change of breaking) {
            lines.push(makeChangeEntry(change, forProject));
        }
        lines.push('');
    }
    if (deprecations.length > 0) {
        lines.push(exports.deprecationsHeader);
        for (const change of deprecations) {
            lines.push(makeChangeEntry(change, forProject));
        }
        lines.push('');
    }
    if (features.length > 0) {
        lines.push(exports.featureChangeHeader);
        for (const change of features) {
            lines.push(makeChangeEntry(change, forProject));
        }
        lines.push('');
    }
    if (bugfixes.length > 0) {
        lines.push(exports.bugFixChangeHeader);
        for (const change of bugfixes) {
            lines.push(makeChangeEntry(change, forProject));
        }
        lines.push('');
    }
    lines.push('');
    return lines.join("\n");
}
function isPrereleaseFor(version, forVersion) {
    return (version.prerelease.length > 0 &&
        forVersion.prerelease.length == 0 &&
        version.compareMain(forVersion) === 0);
}
function updateChangelog(project, changes, forVersion) {
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function* () {
        const forReleaseSemVer = semver_1.default.parse(forVersion);
        const changelogFile = path_1.default.join(project.dir, 'CHANGELOG.md');
        const tmpFile = path_1.default.join(project.dir, 'CHANGELOG.tmp');
        const outHandle = yield promises_1.default.open(tmpFile, 'w');
        let changeWritten = false;
        try {
            for (var _b = __asyncValues(readChangelog(project)), _c; _c = yield _b.next(), !_c.done;) {
                const entry = _c.value;
                if (forReleaseSemVer.compare(entry.version) === 0) {
                    loglevel_1.default.debug(`Found ${entry.version} which is exactly the version we should be updating`);
                    // This is the exact version we should be updating: replace it
                    yield outHandle.write(makeChangelogEntry(changes, forVersion, project));
                    changeWritten = true;
                }
                else if (forReleaseSemVer.compare(entry.version) === 1) {
                    // This one comes before the one we're updating, so if we haven't yet written
                    // our changeset, we need to do it now.
                    if (!changeWritten) {
                        loglevel_1.default.debug(`Writing change before older version ${entry.version}`);
                        yield outHandle.write(makeChangelogEntry(changes, forVersion, project));
                        changeWritten = true;
                    }
                    // and then write the one we found too
                    yield outHandle.write(entry.text);
                }
                else if (isPrereleaseFor(semver_1.default.parse(entry.version), forReleaseSemVer)) {
                    loglevel_1.default.debug(`Found ${entry.version} which is a prerelease of the version we should be updating`);
                    // This is a prerelease of the version we're trying to write, so remove the
                    // prerelease entry from the changelog and replace it with the entry we're
                    // writing, if we haven't already written it
                    if (!changeWritten) {
                        yield outHandle.write(makeChangelogEntry(changes, forVersion, project));
                    }
                }
                else {
                    loglevel_1.default.debug(`Found ${entry.version} which is newer than the version we should be updating`);
                    yield outHandle.write(entry.text);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        yield outHandle.close();
        if (!changeWritten) {
            throw new Error("I failed to write the change... that shouldn't happen");
        }
        yield promises_1.default.unlink(changelogFile);
        yield promises_1.default.rename(tmpFile, changelogFile);
        loglevel_1.default.debug(`Wrote to ${changelogFile}`);
    });
}
exports.updateChangelog = updateChangelog;
