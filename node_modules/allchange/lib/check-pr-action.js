#!/usr/bin/env node
"use strict";
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core = __importStar(require("@actions/core"));
const github = __importStar(require("@actions/github"));
const changelog_1 = require("./changelog");
const changes_1 = require("./changes");
const MAGIC_HEAD = '<!-- CHANGELOG_PREVIEW_START -->\n---\n';
const MAGIC_TAIL = '<!-- CHANGELOG_PREVIEW_END -->';
const MAGIC_COMMENT_REGEXP = /<!-- CHANGELOG_PREVIEW_START -->(.*)<!-- CHANGELOG_PREVIEW_END -->/s;
function updatePrBody(pr, text, octokit) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const wrappedText = MAGIC_HEAD + text + MAGIC_TAIL;
        let newBody;
        console.log("PR body: " + pr.body);
        if ((_a = pr.body) === null || _a === void 0 ? void 0 : _a.match(MAGIC_COMMENT_REGEXP)) {
            console.log("Matched: replacing");
            newBody = pr.body.replace(MAGIC_COMMENT_REGEXP, wrappedText);
        }
        else {
            console.log("No match: appending");
            newBody = (pr.body || '') + "\n\n" + wrappedText;
        }
        octokit.rest.issues.update(Object.assign(Object.assign({}, github.context.repo), { issue_number: github.context.payload.number, body: newBody }));
    });
}
function hasLabel(label, pr) {
    return pr.labels.some(l => l.name === label);
}
function addLabels(octokit, pr) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // If the PR already has a change type label, do nothing
        for (const label of Object.keys(changes_1.labelToChangeType)) {
            if (hasLabel(label, pr))
                return pr;
        }
        const matches = (_a = pr.body) === null || _a === void 0 ? void 0 : _a.match(/^Type: ([\w-]+)/im);
        if (matches) {
            let changeType;
            switch (matches[1].toLowerCase()) {
                case 'enhancement':
                case 'feature':
                    changeType = changes_1.ChangeType.FEATURE;
                    break;
                case 'defect':
                case 'bugfix':
                    changeType = changes_1.ChangeType.BUGFIX;
                    break;
                case 'task':
                case 'internal':
                    changeType = changes_1.ChangeType.TASK;
                    break;
                default:
                    return;
            }
            for (const [label, labelType] of Object.entries(changes_1.labelToChangeType)) {
                if (labelType === changeType && !hasLabel(label, pr)) {
                    console.log("Adding label: " + label);
                    yield octokit.rest.issues.addLabels(Object.assign(Object.assign({}, github.context.repo), { issue_number: pr.number, labels: [label] }));
                }
            }
            console.log("Refreshing PR labels...");
            const resp = yield octokit.rest.pulls.get(Object.assign(Object.assign({}, github.context.repo), { pull_number: pr.number }));
            // we fix up the current object because the thing this endpoint returns
            // isn't quite the same thing. sigh.
            pr.labels = resp.data.labels;
            //return resp.data;
        }
        return pr;
    });
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log("Starting...");
            const myToken = core.getInput('ghToken');
            const octokit = github.getOctokit(myToken);
            // we're assuming the repo name is the same as the project name
            const forProjectName = github.context.repo.repo;
            let pr = github.context.payload.pull_request; // of course the types aren't compatible
            console.log("Scanning for labels to add...");
            pr = yield addLabels(octokit, pr);
            const change = changes_1.changeFromPrInfo(pr);
            const lines = [];
            if (!changes_1.hasChangeTypeLabel(pr)) {
                lines.push("This PR currently has no changelog labels, so will not be included in changelogs.");
                lines.push("");
                const labelsWithFormatting = changes_1.getChangeTypeLabels().map(l => '`' + l + '`').join(", ");
                // This is a very crude approximation of github's permission model.
                // It will almost certainly be wrong sometimes.
                if (['MEMBER', 'OWNER'].includes(change.pr.author_association)) {
                    lines.push(`Add one of: ${labelsWithFormatting} to indicate what type of change this is ` +
                        `plus \`${changes_1.BREAKING_CHANGE_LABEL}\` if it's a breaking change.`);
                }
                else {
                    lines.push(`A reviewer can add one of: ${labelsWithFormatting} to ` +
                        `indicate what type of change this is, or add \`Type: [enhancement/defect/task]\` ` +
                        `to the description and I'll add them for you.`);
                }
            }
            else if (change.changeType === changes_1.ChangeType.TASK) {
                lines.push("This change is marked as an *internal change* (Task), so will not be included in the changelog.");
            }
            else if (change.notes == null) {
                lines.push("This change has no change notes, so will not be included in the changelog.");
            }
            else {
                const entry = changelog_1.makeChangeEntry(change, Object.assign({ name: forProjectName }, github.context.repo));
                lines.push("Here's what your changelog entry will look like:");
                lines.push("");
                if (change.breaking) {
                    lines.push(changelog_1.breakingChangeHeader);
                }
                else if (change.changeType === changes_1.ChangeType.FEATURE) {
                    lines.push(changelog_1.featureChangeHeader);
                }
                else if (change.changeType === changes_1.ChangeType.BUGFIX) {
                    lines.push(changelog_1.bugFixChangeHeader);
                }
                else if (change.changeType === changes_1.ChangeType.DEPRECATION) {
                    lines.push(changelog_1.deprecationsHeader);
                }
                lines.push(entry);
            }
            updatePrBody(pr, lines.join("\n"), octokit);
        }
        catch (error) {
            console.error(error);
            core.setFailed(error.message);
        }
    });
}
main();
