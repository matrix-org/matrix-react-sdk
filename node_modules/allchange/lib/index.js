#!/usr/bin/env node
"use strict";
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const loglevel_1 = __importDefault(require("loglevel"));
const yargs_1 = __importDefault(require("yargs/yargs"));
const helpers_1 = require("yargs/helpers");
const cli_color_1 = __importDefault(require("cli-color"));
const semver_1 = __importDefault(require("semver"));
const changes_1 = require("./changes");
const releases_1 = require("./releases");
const projects_1 = require("./projects");
const issue_1 = require("./issue");
const changelog_1 = require("./changelog");
const rest_1 = require("@octokit/rest");
function formatChangeType(changeType) {
    switch (changeType) {
        case changes_1.ChangeType.FEATURE:
            return 'Feature';
        case changes_1.ChangeType.BUGFIX:
            return 'Bug fix';
        case changes_1.ChangeType.TASK:
        case null:
            return "Internal change";
    }
}
function printChangeStatus(change, projectName, owner, repo) {
    console.log(formatChangeType(change.changeType) + ": " + change.pr.html_url);
    console.log(`\t${change.notes === null ? '<no notes>' : change.notes}`);
    for (const [proj, note] of Object.entries(change.notesByProject)) {
        let fmt = (x) => { return x; };
        if (proj === projectName)
            fmt = cli_color_1.default.bold;
        console.log("\t" + fmt(`${proj} notes: ${note}`));
    }
    if (change.headline) {
        console.log('\t' + cli_color_1.default.bold.inverse(`HEADLINE: ${change.headline}`));
    }
    for (const fixes of change.fixes) {
        console.log("\tFixes " + issue_1.formatIssue(fixes, owner, repo));
    }
    if (change.changeType === null) {
        console.log(cli_color_1.default.red.bold("\t\u26A0\uFE0F  No type label!"));
    }
    if (change.breaking) {
        console.log("\t\uD83D\uDCA5  Marked as breaking");
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const args = yargs_1.default(helpers_1.hideBin(process.argv)).option('debug', {
            alias: 'd',
            type: 'boolean',
            description: "Enable debug mode",
        }).option('check', {
            type: 'boolean',
            description: "Don't update changelog, just output information on what changes would be included",
        }).help().usage("Usage: $0 [-d] [--check] <version>").argv;
        if (args._.length !== 1 && !args.check) {
            // Surely yargs should be able to do this? It seems incredibly confusing and I already regret using it
            console.log("No version specified");
            return;
        }
        const targetRelease = args._[0];
        if (args.debug) {
            loglevel_1.default.setLevel(loglevel_1.default.levels.DEBUG);
        }
        const octo = new rest_1.Octokit({
            auth: process.env.CHANGELOG_GITHUB_TOKEN,
        });
        const dir = process.cwd();
        const projectName = (yield projects_1.getPackageJsonAtVersion(dir, '')).name;
        loglevel_1.default.debug("Project: " + projectName);
        const project = yield projects_1.Project.make(projectName, dir);
        const [owner, repo] = yield changes_1.githubOrgRepoFromDir(dir);
        let branchMode = projects_1.BranchMode.Exact;
        const rels = yield releases_1.getReleases(octo, owner, repo);
        let fromVer;
        let toVer;
        if (targetRelease) {
            const targetReleaseSemVer = semver_1.default.parse(targetRelease);
            const targetIsPrerelease = targetReleaseSemVer.prerelease.length > 0;
            const toVerReleaseBranch = `release-v${targetReleaseSemVer.major}.${targetReleaseSemVer.minor}.${targetReleaseSemVer.patch}`;
            if (releases_1.releasesContains(rels, targetRelease)) {
                loglevel_1.default.debug("Found existing release for " + targetRelease);
                // nb. getReleases only gets the most recent 100 so this won't work
                // for older releases
                fromVer = releases_1.getReleaseBefore(rels, targetRelease, targetIsPrerelease).name;
                toVer = targetRelease;
            }
            else if (targetRelease !== 'develop' && (yield projects_1.branchExists(dir, toVerReleaseBranch))) {
                loglevel_1.default.debug("Found release branch for " + targetRelease);
                // 'to' release has had a release branch cut but not yet a full release
                // compare to the tip of the release branch
                fromVer = releases_1.getLatestRelease(rels, targetIsPrerelease).name;
                toVer = toVerReleaseBranch;
                branchMode = projects_1.BranchMode.Release;
            }
            else {
                loglevel_1.default.debug("Found neither release nor branch for " + targetRelease);
                // the 'to' release is an doesn't-yet-exist future release -
                // compare to the tip of develop (a better piece of software
                // might make this configurable...)
                fromVer = releases_1.getLatestRelease(rels, targetIsPrerelease).name;
                toVer = 'develop';
                branchMode = projects_1.BranchMode.Develop;
            }
        }
        else {
            fromVer = releases_1.getLatestRelease(rels, false).name;
            toVer = 'develop';
            branchMode = projects_1.BranchMode.Develop;
        }
        const changes = {};
        yield project.collectChanges(octo, changes, fromVer, toVer, branchMode);
        const allChanges = [].concat(...Object.values(changes));
        //log.debug(changes);
        if (args.check) {
            console.log(`Will include from home project (${projectName}): `);
            for (const change of changes[projectName].filter(c => c.shouldInclude)) {
                printChangeStatus(change, projectName, owner, repo);
            }
            for (const [subProj, subChanges] of Object.entries(changes)) {
                if (subProj === projectName)
                    continue;
                console.log("\nWill include from " + subProj + ":");
                for (const change of subChanges.filter(c => c.shouldInclude)) {
                    printChangeStatus(change, projectName, owner, repo);
                }
            }
            console.log(`\nWill omit from home project (${projectName}): `);
            for (const change of changes[projectName].filter(c => !c.shouldInclude)) {
                printChangeStatus(change, projectName, owner, repo);
            }
            for (const [subProj, subChanges] of Object.entries(changes)) {
                if (subProj === projectName)
                    continue;
                console.log("\nWill omit from " + subProj + ":");
                for (const change of subChanges.filter(c => !c.shouldInclude)) {
                    printChangeStatus(change, projectName, owner, repo);
                }
            }
            const numBreaking = allChanges.filter(c => c.breaking).length;
            const numFeatures = allChanges.filter(c => c.changeType == changes_1.ChangeType.FEATURE).length;
            let suggestedBumpType;
            if (numBreaking) {
                suggestedBumpType = 'major';
            }
            else if (numFeatures) {
                suggestedBumpType = 'minor';
            }
            else {
                suggestedBumpType = 'patch';
            }
            const suggestedVersion = semver_1.default.inc(fromVer, suggestedBumpType);
            console.log('');
            console.log(`${cli_color_1.default.bold(numBreaking)} breaking changes and ${cli_color_1.default.bold(numFeatures)} features.`);
            console.log(`According to semver, this would be a ${cli_color_1.default.bold(suggestedBumpType)} release.`);
            console.log(`Suggested version number: ${cli_color_1.default.bold(suggestedVersion)}`);
            return;
        }
        loglevel_1.default.debug("Updating changelog entry for " + targetRelease);
        yield changelog_1.updateChangelog(project, allChanges, targetRelease);
    });
}
main();
