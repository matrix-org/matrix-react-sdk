"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = exports.getChangeNotes = exports.branchExists = exports.getPackageJsonAtVersion = exports.BranchMode = void 0;
const loglevel_1 = __importDefault(require("loglevel"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const semver_1 = __importDefault(require("semver"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const changes_1 = require("./changes");
var BranchMode;
(function (BranchMode) {
    BranchMode[BranchMode["Exact"] = 0] = "Exact";
    BranchMode[BranchMode["Release"] = 1] = "Release";
    BranchMode[BranchMode["Develop"] = 2] = "Develop";
})(BranchMode = exports.BranchMode || (exports.BranchMode = {}));
function getPackageJsonAtVersion(dir, ver) {
    return __awaiter(this, void 0, void 0, function* () {
        const gitShow = v => new Promise((resolve, reject) => {
            child_process_1.execFile('git', ['show', `${v}:package.json`], {
                cwd: dir,
            }, (error, stdout) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(JSON.parse(stdout));
                }
            });
        });
        // We previously tried this on both origin/${ver} before just $ver to
        // try to avoid you having to make sure your local copies of branches
        // were merged (ie. so 'git fetch' would be fine) but this doesn't work
        // with the release script as-is because it updates version in package.json
        // and then computes the changelog without a push in between, which does
        // feel like a reasonable thing to do.
        return gitShow(ver);
    });
}
exports.getPackageJsonAtVersion = getPackageJsonAtVersion;
function branchExists(dir, branch) {
    return new Promise(resolve => {
        child_process_1.execFile('git', ['rev-parse', branch], {
            cwd: dir,
        }, (error) => {
            resolve(!error);
        });
    });
}
exports.branchExists = branchExists;
function parseDepVersion(ver, dep) {
    if (isNaN(parseInt(ver[0])))
        throw new Error(`Version ${ver} of dependency ${dep} is not exact!`);
    return 'v' + ver;
}
function getDepVersion(ver, proj, branchMode) {
    if (branchMode === BranchMode.Develop) {
        return 'develop';
    }
    else if (branchMode == BranchMode.Release) {
        const depSemVer = semver_1.default.parse(ver);
        return `release-v${depSemVer.major}.${depSemVer.minor}.${depSemVer.patch}`;
    }
    else {
        return parseDepVersion(ver, proj);
    }
}
function getChangeNotes(change, projectName) {
    if ([changes_1.ChangeType.TASK, null].includes(change.changeType))
        return null;
    return change.notesByProject[projectName] !== undefined ? change.notesByProject[projectName] : change.notes;
}
exports.getChangeNotes = getChangeNotes;
class Project {
    constructor(name, dir) {
        this.name = name;
        this.dir = dir;
        this.releaseConfigCache = null;
        this.owner = null;
        this.repo = null;
    }
    static make(name, dir) {
        return __awaiter(this, void 0, void 0, function* () {
            const proj = new Project(name, dir);
            yield proj.init();
            return proj;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const [owner, repo] = yield changes_1.githubOrgRepoFromDir(this.dir);
            this.owner = owner;
            this.repo = repo;
        });
    }
    getReleaseCfg(dir) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.releaseConfigCache !== null)
                return this.releaseConfigCache;
            try {
                this.releaseConfigCache = js_yaml_1.default.load(yield promises_1.default.readFile(path_1.default.join(dir, 'release_config.yaml')));
                if (this.releaseConfigCache.subprojects === undefined)
                    this.releaseConfigCache.subprojects = {};
                return this.releaseConfigCache;
            }
            catch (_a) {
                return { subprojects: {} };
            }
        });
    }
    shouldIncludeChange(forProject, change, includeByDefault) {
        if (getChangeNotes(change, forProject.name) === null)
            return false;
        if (change.notesByProject[forProject.name])
            return true;
        return includeByDefault;
    }
    collectChanges(octo, changes, fromVer, toVer, branchMode, forProject = this, includeByDefault = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changes[this.name] !== undefined)
                return;
            const releaseConfig = yield this.getReleaseCfg(this.dir);
            loglevel_1.default.debug(`Getting changes in ${this.name} from ${fromVer} to ${toVer}`);
            const mergedPrs = yield changes_1.getMergedPrs(this.dir, fromVer, toVer);
            loglevel_1.default.debug("Found set of merged PRs: " + mergedPrs.map(pr => pr.PrNumber).join(', '));
            loglevel_1.default.debug(`Fetching PR metadata from ${this.owner}/${this.repo}...`);
            const prInfo = yield changes_1.getPrInfo(octo, this.owner, this.repo, mergedPrs);
            changes[this.name] = prInfo.map(changes_1.changeFromPrInfo).map(c => {
                c.shouldInclude = this.shouldIncludeChange(forProject, c, includeByDefault);
                return c;
            });
            const subProjects = releaseConfig.subprojects;
            const subProjectVersAtFromVer = {};
            const subProjectVersAtToVer = {};
            if (Object.keys(subProjects).length > 0) {
                const fromVerPackageJson = yield getPackageJsonAtVersion(this.dir, fromVer);
                const toVerPackageJson = yield getPackageJsonAtVersion(this.dir, toVer);
                for (const proj of Object.keys(subProjects)) {
                    if (subProjects[proj].mirrorVersion) {
                        subProjectVersAtFromVer[proj] = fromVer;
                        subProjectVersAtToVer[proj] = toVer;
                    }
                    else {
                        subProjectVersAtFromVer[proj] = parseDepVersion(fromVerPackageJson.dependencies[proj], proj);
                        subProjectVersAtToVer[proj] = getDepVersion(toVerPackageJson.dependencies[proj], proj, branchMode);
                    }
                    loglevel_1.default.debug(`Getting changes for subproject ${proj}: ` +
                        `${subProjectVersAtFromVer[proj]} - ${subProjectVersAtToVer[proj]}`);
                    // we assume subprojects have checkouts in the same parent directory
                    // as our project, named accordingly
                    const subDir = path_1.default.normalize(path_1.default.join(this.dir, '..', proj));
                    const subProject = yield Project.make(proj, subDir);
                    yield subProject.collectChanges(octo, changes, subProjectVersAtFromVer[proj], subProjectVersAtToVer[proj], branchMode, forProject, includeByDefault && subProjects[proj].includeByDefault);
                }
            }
        });
    }
}
exports.Project = Project;
