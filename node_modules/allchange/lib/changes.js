"use strict";
/*
Copyright 2020-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrInfo = exports.changeFromPrInfo = exports.hasChangeTypeLabel = exports.getChangeTypeLabels = exports.getMergedPrs = exports.githubOrgRepoFromDir = exports.BREAKING_CHANGE_LABEL = exports.labelToChangeType = exports.ChangeType = void 0;
const childProcess = __importStar(require("child_process"));
const readline = __importStar(require("readline"));
const path = __importStar(require("path"));
const fs_1 = require("fs");
const loglevel_1 = __importDefault(require("loglevel"));
const GITHUB_PREFIX = 'https://github.com/';
const NOTES_MAGIC_TEXT = 'notes: ';
const PROJECT_NOTES_REGEX = new RegExp(`^([\\w-]*) ${NOTES_MAGIC_TEXT}(.*)$`, 'i');
const HEADLINE_MAGIC_TEXT = 'headlines: ';
const SQUASH_NUMBER_REGEXP = /\(#(\d+)\)/i; // "Message (#1234)", matching the number
const HASH_NUMBER_ISSUE_REGEXP = /(?:close[sd]?|fix|fixe[sd]|resolve[sd]?):? #(\d+)/i;
const OWNER_HASH_NUMBER_ISSUE_REGEXP = /(?:close[sd]?|fix|fixe[sd]|resolve[sd]?):? ([\w-]*)\/([\w-]*)#(\d+)/i;
const ISSUE_URL_REGEXP = /(?:close[sd]?|fix|fixe[sd]|resolve[sd]?):? https?:\/\/github.com\/([\w-]*)\/([\w-]*)\/issues\/([\d]*)/i;
const MERGE_COMMIT_REGEX = /Merge pull request #(\d+) from (.*)/;
const MAGIC_COMMENT_REGEXP = /<!-- CHANGELOG_PREVIEW_START -->(.*)<!-- CHANGELOG_PREVIEW_END -->/s;
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["FEATURE"] = 0] = "FEATURE";
    ChangeType[ChangeType["BUGFIX"] = 1] = "BUGFIX";
    ChangeType[ChangeType["TASK"] = 2] = "TASK";
    ChangeType[ChangeType["DEPRECATION"] = 3] = "DEPRECATION";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));
exports.labelToChangeType = {
    'T-Deprecation': ChangeType.DEPRECATION,
    'T-Enhancement': ChangeType.FEATURE,
    'T-Defect': ChangeType.BUGFIX,
    'T-Task': ChangeType.TASK,
};
exports.BREAKING_CHANGE_LABEL = 'X-Breaking-Change';
function githubOrgRepoFromDir(repoDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJson = JSON.parse(yield fs_1.promises.readFile(path.join(repoDir, 'package.json'), {
            encoding: 'utf8',
        }));
        if (!pkgJson.repository || pkgJson.repository.type !== 'git') {
            throw new Error(repoDir + " doesn't have a 'git' type repo in package.json!");
        }
        if (!pkgJson.repository.url.startsWith(GITHUB_PREFIX)) {
            throw new Error(repoDir + "'s repository isn't a github https url!'");
        }
        const parts = pkgJson.repository.url.slice(GITHUB_PREFIX.length).split('/');
        if (parts.length !== 2) {
            throw new Error('Malformed github URL in repository URL for ' + repoDir);
        }
        return parts;
    });
}
exports.githubOrgRepoFromDir = githubOrgRepoFromDir;
function getMergedPrs(repoDir, from, to) {
    // ew: look for some common branch names and look for the origin versions so we don't
    // rely on the local copy of the branches being pulled
    // better way of doing this? when getting the package.json we just try the 'origin' version first
    const hackRevision = rev => {
        if (rev.startsWith('release') || rev === 'develop')
            return 'origin/' + rev;
        return rev;
    };
    return new Promise((resolve) => {
        const proc = childProcess.spawn('git', [
            'rev-list',
            // '--merges', // we have squash merges now, so can't filter
            '--format=medium',
            '^' + hackRevision(from),
            hackRevision(to),
        ], {
            cwd: repoDir,
        });
        const rl = readline.createInterface({
            input: proc.stdout,
        });
        const prs = [];
        let commit;
        rl.on('line', line => {
            const trimmed = line.trim();
            if (trimmed.startsWith('commit ')) {
                commit = trimmed.split(' ')[1];
            }
            const match = trimmed.match(MERGE_COMMIT_REGEX);
            const squashMatch = trimmed.match(SQUASH_NUMBER_REGEXP);
            if (match) {
                prs.push({
                    PrNumber: parseInt(match[1]),
                    sha: commit,
                });
            }
            else if (squashMatch) {
                prs.push({
                    PrNumber: parseInt(squashMatch[1]),
                    sha: commit,
                });
            }
        });
        rl.on('close', () => {
            resolve(prs);
        });
    });
}
exports.getMergedPrs = getMergedPrs;
function getChangeTypeLabels() {
    return Object.keys(exports.labelToChangeType);
}
exports.getChangeTypeLabels = getChangeTypeLabels;
function hasChangeTypeLabel(pr) {
    const changeLabels = getChangeTypeLabels();
    for (const lbl of pr.labels) {
        if (changeLabels.includes(lbl.name))
            return true;
    }
    return false;
}
exports.hasChangeTypeLabel = hasChangeTypeLabel;
function changeFromPrInfo(pr) {
    let breaking = false;
    const security = false;
    let changeType = null;
    for (const label of pr.labels) {
        if (exports.labelToChangeType[label.name] !== undefined) {
            changeType = exports.labelToChangeType[label.name];
        }
        else if (label.name === exports.BREAKING_CHANGE_LABEL) {
            breaking = true;
        }
    }
    // security fixes are annoying: we normally do them with github's security advisory
    // tooling, but this creates a temporary private fork and merges the changes in with a merge
    // commit similar to a PR, but no github pull object ever exists. Best we could do is
    // parse the body of the merge commit to try to work out that it's a security fix.
    /*if () {
        security = true;
    }*/
    let notes = pr.title;
    let headline = null;
    const notesByProject = {};
    let matches;
    const fixes = new Map();
    if (pr.body) {
        const bodyMainContent = pr.body.replace(MAGIC_COMMENT_REGEXP, "");
        for (const line of bodyMainContent.split("\n")) {
            const trimmed = line.trim();
            if (trimmed.toLowerCase().startsWith(NOTES_MAGIC_TEXT)) {
                notes = trimmed.split(':', 2)[1].trim();
                if (notes.toLowerCase() === 'none')
                    notes = null;
            }
            else if (trimmed.toLowerCase().startsWith(HEADLINE_MAGIC_TEXT)) {
                headline = trimmed.split(':', 2)[1].trim();
            }
            else if (matches = line.match(PROJECT_NOTES_REGEX)) {
                notesByProject[matches[1]] = matches[2].trim();
                if (notesByProject[matches[1]].toLowerCase() === 'none')
                    notesByProject[matches[1]] = null;
            }
            else if (matches = line.match(HASH_NUMBER_ISSUE_REGEXP)) {
                // bafflingly, github's API doesn't give you issues fixed by this PR,
                // so let's try to parse it ourselves (although of course this will only
                // get ones in the PR body, not the comments...)
                const issue = {
                    owner: pr.base.repo.owner.name,
                    repo: pr.base.repo.name,
                    number: parseInt(matches[1]),
                };
                fixes.set(`${issue.owner}/${issue.repo}#${issue.number}`, issue);
            }
            else if (matches = line.match(OWNER_HASH_NUMBER_ISSUE_REGEXP)) {
                const issue = {
                    owner: matches[1],
                    repo: matches[2],
                    number: parseInt(matches[3]),
                };
                fixes.set(`${issue.owner}/${issue.repo}#${issue.number}`, issue);
            }
            else if (matches = line.match(ISSUE_URL_REGEXP)) {
                const issue = {
                    owner: matches[1],
                    repo: matches[2],
                    number: parseInt(matches[3]),
                };
                fixes.set(`${issue.owner}/${issue.repo}#${issue.number}`, issue);
            }
        }
    }
    return {
        pr,
        notes,
        notesByProject,
        headline,
        changeType,
        fixes: [...fixes.values()],
        breaking,
        security,
    };
}
exports.changeFromPrInfo = changeFromPrInfo;
function getPrInfo(octo, repoOwner, repoName, mergeCommits) {
    return __awaiter(this, void 0, void 0, function* () {
        const prMap = new Map();
        for (const c of mergeCommits) {
            prMap.set(c.PrNumber, c.sha);
        }
        const mergedPrInfo = [];
        // This is how you're supposed to paginate with octokit, but it seems like the types are
        // so screwed that typescript can't resolve them (the below sinppet failed to compile).
        // You're not supposed to use pagination directly because some APIs have sensible pagination
        // APIs with prev/next references. This one doesn't though, so it doesn't really matter.
        /*
        octo.paginate('GET /repos/{owner}/{repo}/pulls', {
            owner: 'matrix-org',
            repo: 'matrix-react-sdk',
            state: 'closed',
            sort: 'created',
            direction: 'desc',
            per_page: 100,
        }, (resp, done: () => void): void => {
            return resp;
        });
        */
        const checkAndAddPrInfo = (prInfo) => {
            const expectedSha = prMap.get(prInfo.number);
            if (prInfo.merge_commit_sha === expectedSha) {
                mergedPrInfo.push(prInfo);
            }
            else {
                loglevel_1.default.debug(`Ignoring PR ${prInfo.number} because merge commit ` +
                    `(${prInfo.merge_commit_sha}) doesn't match git (${expectedSha})`);
            }
            prMap.delete(prInfo.number);
        };
        let pageNum = 1;
        while (prMap.size > 0) {
            if (prMap.size === 1) {
                const prNum = prMap.keys().next().value;
                loglevel_1.default.debug(`Fetching remaining PR ${prNum} individually...`);
                const prResp = yield octo.pulls.get({
                    owner: repoOwner,
                    repo: repoName,
                    pull_number: prNum,
                });
                // XXX: The object shapes of items in the 'list pulls' API and what you
                // get from the 'get pull' API are different. Hopefully they're close
                // enough for our purposes...
                checkAndAddPrInfo(prResp.data);
                break;
            }
            // Github doesn't have a way to get multiple PRs at once, but we can list them
            // all. Since we generally want the most recent, this is probably fine and is a
            // single API call rather than one for each merged PR.
            loglevel_1.default.debug(prMap.size + " PRs left to find");
            loglevel_1.default.debug("Still have to find: " + Array.from(prMap.keys()).join(', '));
            loglevel_1.default.debug("Getting page " + pageNum);
            const prListResp = yield octo.rest.pulls.list({
                owner: repoOwner,
                repo: repoName,
                state: 'closed',
                sort: 'updated',
                direction: 'desc',
                per_page: 100,
                page: pageNum,
            });
            //console.log("Got PRs: " + prListResp.data.map(pr => pr.number).join(', '));
            if (prListResp.data.length === 0)
                break;
            for (const pr of prListResp.data) {
                if (prMap.has(pr.number)) {
                    checkAndAddPrInfo(pr);
                }
            }
            pageNum++;
        }
        if (prMap.size > 0) {
            loglevel_1.default.debug("Found info on prs: " + mergedPrInfo.map(pr => pr.number).join(', '));
            loglevel_1.default.debug("Couldn't find: " + Array.from(prMap).join(', '));
            // 100 is the max per page so if we didn't find them all, we'll have to paginate
            throw new Error("Couldn't find all PRs");
        }
        return mergedPrInfo;
    });
}
exports.getPrInfo = getPrInfo;
