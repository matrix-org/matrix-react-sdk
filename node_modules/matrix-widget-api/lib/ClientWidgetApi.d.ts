import { EventEmitter } from "events";
import { ITransport } from "./transport/ITransport";
import { Widget } from "./models/Widget";
import { Capability } from "./interfaces/Capabilities";
import { WidgetDriver } from "./driver/WidgetDriver";
import { IScreenshotActionResponseData } from "./interfaces/ScreenshotAction";
import { IWidgetApiResponseData } from "./interfaces/IWidgetApiResponse";
import { IModalWidgetOpenRequestData, IModalWidgetOpenRequestDataButton, IModalWidgetReturnData } from "./interfaces/ModalWidgetActions";
import { IRoomEvent } from "./interfaces/IRoomEvent";
import { Symbols } from "./Symbols";
/**
 * API handler for the client side of widgets. This raises events
 * for each action received as `action:${action}` (eg: "action:screenshot").
 * Default handling can be prevented by using preventDefault() on the
 * raised event. The default handling varies for each action: ones
 * which the SDK can handle safely are acknowledged appropriately and
 * ones which are unhandled (custom or require the client to do something)
 * are rejected with an error.
 *
 * Events which are preventDefault()ed must reply using the transport.
 * The events raised will have a default of an IWidgetApiRequest
 * interface.
 *
 * When the ClientWidgetApi is ready to start sending requests, it will
 * raise a "ready" CustomEvent. After the ready event fires, actions can
 * be sent and the transport will be ready.
 *
 * When the widget has indicated it has loaded, this class raises a
 * "preparing" CustomEvent. The preparing event does not indicate that
 * the widget is ready to receive communications - that is signified by
 * the ready event exclusively.
 *
 * This class only handles one widget at a time.
 */
export declare class ClientWidgetApi extends EventEmitter {
    readonly widget: Widget;
    private iframe;
    private driver;
    readonly transport: ITransport;
    private contentLoadedActionSent;
    private allowedCapabilities;
    private allowedEvents;
    private isStopped;
    /**
     * Creates a new client widget API. This will instantiate the transport
     * and start everything. When the iframe is loaded under the widget's
     * conditions, a "ready" event will be raised.
     * @param {Widget} widget The widget to communicate with.
     * @param {HTMLIFrameElement} iframe The iframe the widget is in.
     * @param {WidgetDriver} driver The driver for this widget/client.
     */
    constructor(widget: Widget, iframe: HTMLIFrameElement, driver: WidgetDriver);
    hasCapability(capability: Capability): boolean;
    canUseRoomTimeline(roomId: string | Symbols.AnyRoom): boolean;
    canSendRoomEvent(eventType: string, msgtype?: string): boolean;
    canSendStateEvent(eventType: string, stateKey: string): boolean;
    canReceiveRoomEvent(eventType: string, msgtype?: string): boolean;
    canReceiveStateEvent(eventType: string, stateKey: string): boolean;
    stop(): void;
    private beginCapabilities;
    private notifyCapabilities;
    private onIframeLoad;
    private handleContentLoadedAction;
    private replyVersions;
    private handleCapabilitiesRenegotiate;
    private handleNavigate;
    private handleOIDC;
    private handleReadEvents;
    private handleSendEvent;
    private handleMessage;
    /**
     * Takes a screenshot of the widget.
     * @returns Resolves to the widget's screenshot.
     * @throws Throws if there is a problem.
     */
    takeScreenshot(): Promise<IScreenshotActionResponseData>;
    /**
     * Alerts the widget to whether or not it is currently visible.
     * @param {boolean} isVisible Whether the widget is visible or not.
     * @returns {Promise<IWidgetApiResponseData>} Resolves when the widget acknowledges the update.
     */
    updateVisibility(isVisible: boolean): Promise<IWidgetApiResponseData>;
    sendWidgetConfig(data: IModalWidgetOpenRequestData): Promise<void>;
    notifyModalWidgetButtonClicked(id: IModalWidgetOpenRequestDataButton["id"]): Promise<void>;
    notifyModalWidgetClose(data: IModalWidgetReturnData): Promise<void>;
    /**
     * Feeds an event to the widget. If the widget is not able to accept the event due to
     * permissions, this will no-op and return calmly. If the widget failed to handle the
     * event, this will raise an error.
     * @param {IRoomEvent} rawEvent The event to (try to) send to the widget.
     * @param {string} currentViewedRoomId The room ID the user is currently interacting with.
     * Not the room ID of the event.
     * @returns {Promise<void>} Resolves when complete, rejects if there was an error sending.
     */
    feedEvent(rawEvent: IRoomEvent, currentViewedRoomId: string): Promise<void>;
}
