declare type HttpMethod = 'GET' | 'PUT' | 'POST' | 'DELETE';
declare type Callback = (err?: Error, response?: XMLHttpRequest | ExpectedRequestResponse['response'], body?: string) => void;
declare type RequestOpts = {
    method: HttpMethod;
    uri: string;
    body?: string;
    qs?: Record<string, string>;
    headers?: Record<string, string>;
};
/**
 * Construct a mock HTTP backend, heavily inspired by Angular.js.
 * @constructor
 */
declare class HttpBackend {
    requests: Request[];
    expectedRequests: ExpectedRequest[];
    _flushPromises: Promise<unknown>[];
    requestFn: (opts: RequestOpts, callback: Callback) => {
        abort: () => void;
    };
    fetchFn: (input: string, init?: Omit<RequestOpts, 'uri'>) => Promise<{
        ok: boolean;
        json: () => unknown;
    }>;
    /**
     * Respond to all of the requests (flush the queue).
     * @param {string} path The path to flush (optional) default: all.
     * @param {integer} numToFlush The number of things to flush (optional), default: all.
     * @param {integer=} waitTime  The time (in ms) to wait for a request to happen.
     *    default: 100
     *
     * @return {Promise} resolves when there is nothing left to flush, with the
     *    number of requests flushed
     */
    flush: (path: string | undefined, numToFlush?: number, waitTime?: number) => Promise<number>;
    /**
     * Repeatedly flush requests until the list of expectations is empty.
     *
     * There is a total timeout (of 1000ms by default), after which the returned
     * promise is rejected.
     *
     * @param {Object=} opts Options object
     * @param {Number=} opts.timeout Total timeout, in ms. 1000 by default.
     * @return {Promise} resolves when there is nothing left to flush, with the
     *    number of requests flushed
     */
    flushAllExpected: (opts?: {
        timeout?: number;
    }) => Promise<number>;
    /**
     * Attempts to resolve requests/expected requests.
     * @param {string} path The path to flush (optional) default: all.
     * @return {boolean} true if something was resolved.
     */
    private _takeFromQueue;
    /**
     * Makes sure that the SDK hasn't sent any more requests to the backend.
     */
    verifyNoOutstandingRequests: () => void;
    /**
     * Makes sure that the test doesn't have any unresolved requests.
     */
    verifyNoOutstandingExpectation: () => void;
    /**
     * Create an expected request.
     * @param {string} method The HTTP method
     * @param {string} path The path (which can be partial)
     * @param {Object} data The expected data.
     * @return {Request} An expected request.
     */
    when: (method: HttpMethod, path: string, data?: Record<string, string>) => ExpectedRequest;
    /**
     * @return {Promise} resolves once all pending flushes are complete.
     */
    stop: () => Promise<unknown[]>;
}
declare type RequestCheckFunction = (request: Request) => void;
declare type ExpectedRequestResponse = {
    response: {
        statusCode: number;
        headers: Record<string, string>;
    };
    body: null | any;
    err?: Error;
    rawBody?: boolean;
};
/**
 * Represents the expectation of a request.
 *
 * <p>Includes the conditions to be matched against, the checks to be made,
 * and the response to be returned.
 *
 * @constructor
 * @param {string} method
 * @param {string} path
 * @param {object?} data
 */
declare class ExpectedRequest {
    readonly method: HttpMethod;
    readonly path: string;
    readonly data?: Record<string, string>;
    response: ExpectedRequestResponse | null;
    checks: RequestCheckFunction[];
    constructor(method: HttpMethod, path: string, data?: Record<string, string>);
    toString: () => string;
    /**
     * Execute a check when this request has been satisfied.
     * @param {Function} fn The function to execute.
     * @return {Request} for chaining calls.
     */
    check: (fn: RequestCheckFunction) => ExpectedRequest;
    /**
     * Respond with the given data when this request is satisfied.
     * @param {Number} code The HTTP status code.
     * @param {Object|Function?} data The response body object. If this is a function,
     * it will be invoked when the response body is required (which should be returned).
     * @param {Boolean} rawBody true if the response should be returned directly rather
     * than json-stringifying it first.
     */
    respond: <T = Record<string, unknown>, R = Record<string, unknown>>(code: number, data?: T | ((path: string, data: R, request: Request) => T), rawBody?: boolean) => void;
    /**
     * Fail with an Error when this request is satisfied.
     * @param {Number} code The HTTP status code.
     * @param {Error} err The error to throw (e.g. Network Error)
     */
    fail: (code: number, err: Error) => void;
}
/**
 * Represents a request made by the app.
 *
 * @constructor
 * @param {object} opts opts passed to request()
 * @param {function} callback
 */
declare class Request {
    private readonly opts;
    readonly callback: Callback;
    constructor(opts: RequestOpts, callback: Callback);
    get method(): HttpMethod;
    get path(): string;
    get data(): any;
    get rawData(): string;
    get queryParams(): Record<string, string> | undefined;
    get headers(): Record<string, string>;
    toString(): string;
}
/**
 * The HttpBackend class.
 */
export default HttpBackend;
